"use strict"; 

-- DEVICES --
local pmPanelDev = 0
local pmPartitionDev_t  = { 0, 0, 0 }
local pmSensorDev_t = {} -- id, name, stype, sid, sname, ztype, zname, zchime, partition, bypass, lowbatt
local pmSirenDev_t = {}
local pmImperiHomeDev = nil
local pmPanelTypeNr = 3 -- assume Powerlink Pro (no partitions) by default
local pmPowerMaster = (pmPanelTypeNr >= 8)
-- MESSAGE HANDLING --
local pmIncomingPdu = ""
local pmIncomingPduLen = nil
local pmVarLenMsg = false
local pmLastPDU = ""
local pmOutgoingQueue = Queue.new()
local pmMsgDelayed = nil
local pmWaitingForResponse = 0
local pmLastSendMsg = ""
local pmExpectedResponse = ""
local pmSendMsgRetries = 0
local pmCrcErrorCount = 0
local pmTiming = "high"
local pmTimeFunction = nil
local TIMEOUT = 9 -- wait max. 9 sec for a response (actually 20 due to timer interval)
local MSG_RETRIES = 3
local MAX_CRC_ERROR = 5
local MAX_EXCEPTIONS = 3
-- SETTINGS --
local pmRawSettings_t = {}
local pmSettings_t = {
   -- phonenrs
   -- belltime
   -- quickarm
}
local pmReadAllSettings = false
local pmPincode_t = { string.char(0x00, 0x00) }
local pmPhoneNr_t = {}
local pmZoneNameRaw_t = {}
local pmBellTime = 0;
local pmSilentPanic = false;
local pmQuickArm = false;
local pmBypassOff = false;
local pmLang = "EN"
local pmMotionOffDelay = 3
local pmRemoteArm = "false"
local pmSensorArm = "auto"
local pmSensorShowBypass = true
local pmEncryptionKey = ""
local pmSpeakLevel = 2
-- EVENT LOG --
local pmEventLog_t = { done = true, items = 0 }
local pmEventCnt
-- POWERLINK --
local pmStarting = false
local pmDownloadCode = "VP" -- Vera Powerlink
local pmPowerlinkMode = false
local pmLastKeepAlive = nil
local pmPowerlinkRetry = 0
local PL_RETRIES = 3
--- STATE INFO ---
local pmSysStatus
local pmSirenActive = nil
local pmUserCalling = 1
--- DEBUGGING ---
local pmLogDebug = true
local pmLogPath = "/var/log/cmh/"
local pmLogFilename = "<id>_powermax_pdu.txt"
local pmSettingsFilename = "<id>_powermax_settings.txt"
local pmCrashFilename = "<id>_powermax_crash.txt"
local pmSyncTimeCheck = nil
local pmBackupMagic = "PMBv1"

local pmPanelInit_t = {
   { "PluginVersion", PLUGIN_VERSION, false }, -- false: update
   { "MotionOffDelay", pmMotionOffDelay, true }, -- true: create only
   { "PluginLanguage", pmLang, true },
   { "PluginDebug", "0", true },
   { "LogPath", "/var/log/cmh/pm/", true },
   { "ForceStandard", "0", true },
   { "AutoCreate", "1", true },
   { "AutoSyncTime", "1", true },
   { "EnableRemoteArm", pmRemoteArm, true },
   { "EnableProgram", "0", true },
   { "SensorArm", pmSensorArm, true },
   { "DoorZones", "", true },
   { "MotionZones", "", true },
   { "SmokeZones", "", true },
   { "Devices", "", true },
   { "PowerlinkMode", "Unknown", false },
   { "PanelStatusCode", "", true },
   { "PanelStatusData", "", true },
   { "PanelAlarmType", "", true },
   { "PanelTroubleType", "", true }
}

local PANEL_SID        = "urn:micasaverde-com:serviceId:PowermaxAlarmPanel1"
local PARTITION_SID    = "urn:micasaverde-com:serviceId:AlarmPartition2"
local SECURITY_SID     = "urn:micasaverde-com:serviceId:SecuritySensor1"
local HA_DEV_SID       = "urn:micasaverde-com:serviceId:HaDevice1"
local KEYPAD_SID       = "urn:micasaverde-com:serviceId:Keypad1"
     
local X10DEVICE_SID    = "urn:upnp-org:serviceId:SwitchPower1"
local X10DEVICEDIM_SID = "urn:upnp-org:serviceId:Dimming1"
local ENERGY_SID       = "urn:micasaverde-com:serviceId:EnergyMetering1"
local SIREN_SID        = "urn:upnp-org:serviceId:SwitchPower1"

local IMPERIHOME_DEV   = "urn:schemas-imperihome-com:device:ImperiHomeDevice:1"
local IMPERIHOME_SID   = "urn:imperihome-com:serviceId:ImperiHomeDevice1"

local CON_X10SW_INIT  = X10DEVICE_SID .. ",Target=0\n" .. X10DEVICE_SID .. ",Status=0\n" .. ENERGY_SID .. ",Watts=\n" .. ENERGY_SID .. ",UserSuppliedWattage="
local CON_X10DIM_INIT = CON_X10SW_INIT .. "\n" .. X10DEVICEDIM_SID .. ",LoadLevelTarget=0\n" .. X10DEVICEDIM_SID .. ",LoadLevelStatus=0"
local CON_SENSOR_INIT = SECURITY_SID .. ",Tripped=0"
local CON_BATSENSOR_INIT = CON_SENSOR_INIT .. "\n" .. HA_DEV_SID .. ",BatteryLevel=100"
local CON_SIREN       = X10DEVICE_SID .. ",Target=0\n" .. X10DEVICE_SID .. ",Status=0\n"
local CON_KEYPAD      = KEYPAD_SID .. ",Status=0"

local pmDevices_t = {
   VAR_PARTITION = { "urn:schemas-micasaverde-com:device:AlarmPartition:2", "D_PowermaxPartition2.xml", "", "", true },
   VAR_SWITCH    = { "urn:schemas-upnp-org:device:BinaryLight:1", "D_BinaryLight1.xml", "", CON_X10SW_INIT, false },
   VAR_DIM       = { "urn:schemas-upnp-org:device:DimmableLight:1", "D_DimmableLight1.xml", "",CON_X10DIM_INIT, false },
   VAR_MAGNET    = { "urn:schemas-micasaverde-com:device:DoorSensor:1", "D_DoorSensor1.xml", "", CON_BATSENSOR_INIT, false },
   VAR_MOTION    = { "urn:schemas-micasaverde-com:device:MotionSensor:1", "D_MotionSensor1.xml", "", CON_BATSENSOR_INIT, false },
   VAR_SMOKE     = { "urn:schemas-micasaverde-com:device:SmokeSensor:1", "D_SmokeSensor1.xml", "", CON_BATSENSOR_INIT, false },
   VAR_GAS       = { "urn:schemas-micasaverde-com:device:SmokeSensor:1", "D_SmokeSensor1.xml", "", CON_BATSENSOR_INIT, false },
   VAR_SIREN     = { "urn:schemas-micasaverde-com:device:Siren:1", "D_Siren1.xml", "", CON_SIREN, false },
   VAR_KEYPAD    = { "urn:schemas-micasaverde-com:device:Keypad:1", "D_Keypad1.xml", "", CON_KEYPAD, false }
}

-- PowerMax messages we send
-- E1: message string
-- E2: expected response after ACK (nil if none)
local pmSendMsg_t = {
   MSG_INIT      = { string.char(0xAB, 0x0A, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43), nil },
   MSG_ZONENAME  = { string.char(0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43), nil },
   MSG_ZONETYPE  = { string.char(0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43), nil },
   MSG_X10NAMES  = { string.char(0xAC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43), nil },
   MSG_RESTORE   = { string.char(0xAB, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43), 0xA5 },
   MSG_ENROLL    = { string.char(0xAB, 0x0A, 0x00, 0x00) .. pmDownloadCode .. string.char(0x00, 0x00, 0x00, 0x00, 0x00, 0x43), nil },
   MSG_EVENTLOG  = { string.char(0xA0, 0x00, 0x00, 0x00) .. "pin" .. string.char(0x00, 0x00, 0x00, 0x00, 0x00, 0x43), 0xA0 },
   MSG_ARM       = { string.char(0xA1, 0x00, 0x00) .. "armpin" .. string.char(0x00, 0x00, 0x00, 0x00, 0x00, 0x43), nil },
   MSG_STATUS    = { string.char(0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43), 0xA5 },
   MSG_BYPASSTAT = { string.char(0xA2, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43), 0xA5 },
   MSG_ZONENAME  = { string.char(0xA3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43), 0xA3 },
   MSG_X10PGM    = { string.char(0xA4, 0x00, 0x00, 0x00, 0x00, 0x00) .. "cmddevice" .. string.char(0x00, 0x00, 0x43), nil },
   MSG_ZONETYPE  = { string.char(0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43), 0xA6 },
   MSG_BYPASSEN  = { string.char(0xAA) .. "pinbypass" .. string.char(0x00, 0x00, 0x00, 0x00, 0x43), nil },
   MSG_BYPASSDIS = { string.char(0xAA) .. "pin" .. string.char(0x00, 0x00, 0x00, 0x00) .. "bypass" .. string.char(0x43), nil },
   MSG_X10NAME   = { string.char(0xAC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43), 0xAC },
   MSG_DOWNLOAD  = { string.char(0x24, 0x00, 0x00) .. pmDownloadCode.. string.char(0x00, 0x00, 0x00, 0x00, 0x00, 0x00), 0x3C },
   MSG_SETTIME   = { string.char(0x46, 0xF8, 0x00) .. "time" .. string.char(0xFF, 0xFF), nil },
   MSG_WRITE     = { string.char(0x3D) .. "addrlenval", nil },
   MSG_DL        = { string.char(0x3E) .. "item" .. string.char(0xB0, 0x00, 0x00, 0x00, 0x00, 0x00), 0x3F },
   MSG_SER_TYPE  = { string.char(0x5A, 0x30, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00), 0x33 },
   MSG_START     = { string.char(0x0A), 0x33 },
   MSG_EXIT      = { string.char(0x0F), nil },
   -- PowerMaster specific
   MSG_POWERMASTER = { string.char(0xB0, 0x01) .. "msg" .. string.char(0x43), 0xB0 }
}

pmDownloadItem_t = {
   MSG_DL_TIME       = string.char(0xF8, 0x00, 0x06, 0x00),
   MSG_DL_COMMDEF    = string.char(0x01, 0x01, 0x1E, 0x00),
   MSG_DL_PHONENRS   = string.char(0x36, 0x01, 0x20, 0x00),
   MSG_DL_PINCODES   = string.char(0xFA, 0x01, 0x10, 0x00),
   MSG_DL_PGMX10     = string.char(0x14, 0x02, 0xD5, 0x00),
   MSG_DL_PARTITIONS = string.char(0x00, 0x03, 0xF0, 0x00),
   MSG_DL_PANELFW    = string.char(0x00, 0x04, 0x20, 0x00),
   MSG_DL_SERIAL     = string.char(0x30, 0x04, 0x08, 0x00),
   MSG_DL_ZONES      = string.char(0x00, 0x09, 0x78, 0x00),
   MSG_DL_KEYFOBS    = string.char(0x78, 0x09, 0x40, 0x00),
   MSG_DL_2WKEYPAD   = string.char(0x00, 0x0A, 0x08, 0x00),
   MSG_DL_1WKEYPAD   = string.char(0x20, 0x0A, 0x40, 0x00),
   MSG_DL_SIRENS     = string.char(0x60, 0x0A, 0x08, 0x00),
   MSG_DL_X10NAMES   = string.char(0x30, 0x0B, 0x10, 0x00),
   MSG_DL_ZONENAMES  = string.char(0x40, 0x0B, 0x1E, 0x00),
   MSG_DL_EVENTLOG   = string.char(0xDF, 0x04, 0x28, 0x03),
   MSG_DL_ZONESTR    = string.char(0x00, 0x19, 0x00, 0x02),
   MSL_DL_ZONECUSTOM = string.char(0xA0, 0x1A, 0x50, 0x00),
   MSG_DL_MR_ZONENAMES = string.char(0x60, 0x09, 0x40, 0x00),
   MSG_DL_MR_PINCODES  = string.char(0x98, 0x0A, 0x60, 0x00),
   MSG_DL_MR_SIRENS    = string.char(0xE2, 0xB6, 0x50, 0x00),
   MSG_DL_MR_KEYPADS   = string.char(0x32, 0xB7, 0x40, 0x01),
   MSG_DL_MR_ZONES     = string.char(0x72, 0xB8, 0x80, 0x02),
   MSG_DL_MR_SIRKEYZON = string.char(0xE2, 0xB6, 0x10, 0x04), -- Combines Sirens, keypads and sensors
   MSG_DL_ALL        = string.char(0x00, 0x00, 0x00, 0xFF)
}

-- Message types we can receive with their length (nil=variable), handlers and whether they need an ACK
local pmReceiveMsg_t = {
   [0x02] = { nil, pmHandleAck, false },
   [0x06] = { nil, pmHandleTimeout, false },
   [0x08] = { nil, pmHandleDenied, true },
   [0x0B] = { nil, pmHandleStop, true },
   [0x25] = { 14, pmHandleDownloadRetry, true },
   [0x33] = { 14, pmHandleSettings, true },
   [0x3C] = { 14, pmHandleInfo, true },
   [0x3F] = { nil, pmHandleSettingsItem, true },
   [0xA0] = { 15, pmHandleEventlog, true },
   [0xA3] = { 15, pmHandleZoneName, true },
   [0xA5] = { 15, pmHandleStatus, true },
   [0xA6] = { 15, pmHandleZoneType, true },
   [0xA7] = { 15, pmHandlePanel, true },
   [0xAB] = { 15, pmHandlePowerlink, false },
   [0xB0] = { nil, pmHandlePowerMaster, true },
   [0xF1] = { 9, nil, false }
}

local pmReceiveMsgB0_t = {
   [0x04] = { txt = "Zone status" },
   [0x18] = { txt = "Open/close status" },
   [0x39] = { txt = "Activity" }
}

local pmMsgTiming_t = {
   high = { func = socket.gettime, wait = 0.5, delay = 1 },
   low  = { func = os.time, wait = 1, delay = 2 }
}

local pmLogEvent_t = { 
   EN = {
   "None", "Interior Alarm", "Perimeter Alarm", "Delay Alarm", "24h Silent Alarm", "24h Audible Alarm",
   "Tamper", "Control Panel Tamper", "Tamper Alarm", "Tamper Alarm", "Communication Loss", "Panic From Keyfob",
   "Panic From Control Panel", "Duress", "Confirm Alarm", "General Trouble", "General Trouble Restore", 
   "Interior Restore", "Perimeter Restore", "Delay Restore", "24h Silent Restore", "24h Audible Restore",
   "Tamper Restore", "Control Panel Tamper Restore", "Tamper Restore", "Tamper Restore", "Communication Restore",
   "Cancel Alarm", "General Restore", "Trouble Restore", "Not used", "Recent Close", "Fire", "Fire Restore", 
   "No Active", "Emergency", "No used", "Disarm Latchkey", "Panic Restore", "Supervision (Inactive)",
   "Supervision Restore (Active)", "Low Battery", "Low Battery Restore", "AC Fail", "AC Restore",
   "Control Panel Low Battery", "Control Panel Low Battery Restore", "RF Jamming", "RF Jamming Restore",
   "Communications Failure", "Communications Restore", "Telephone Line Failure", "Telephone Line Restore",
   "Auto Test", "Fuse Failure", "Fuse Restore", "Keyfob Low Battery", "Keyfob Low Battery Restore", "Engineer Reset",
   "Battery Disconnect", "1-Way Keypad Low Battery", "1-Way Keypad Low Battery Restore", "1-Way Keypad Inactive",
   "1-Way Keypad Restore Active", "Low Battery", "Clean Me", "Fire Trouble", "Low Battery", "Battery Restore",
   "AC Fail", "AC Restore", "Supervision (Inactive)", "Supervision Restore (Active)", "Gas Alert", "Gas Alert Restore",
   "Gas Trouble", "Gas Trouble Restore", "Flood Alert", "Flood Alert Restore", "X-10 Trouble", "X-10 Trouble Restore",
   "Arm Home", "Arm Away", "Quick Arm Home", "Quick Arm Away", "Disarm", "Fail To Auto-Arm", "Enter To Test Mode",
   "Exit From Test Mode", "Force Arm", "Auto Arm", "Instant Arm", "Bypass", "Fail To Arm", "Door Open",
   "Communication Established By Control Panel", "System Reset", "Installer Programming", "Wrong Password",
   "Not Sys Event", "Not Sys Event", "Extreme Hot Alert", "Extreme Hot Alert Restore", "Freeze Alert", 
   "Freeze Alert Restore", "Human Cold Alert", "Human Cold Alert Restore", "Human Hot Alert",
   "Human Hot Alert Restore", "Temperature Sensor Trouble", "Temperature Sensor Trouble Restore",
   -- new values partition models
   "PIR Mask", "PIR Mask Restore", "", "", "", "", "", "", "", "", "", "",
   "Alarmed", "Restore", "Alarmed", "Restore", "", "", "", "", "", "", "", "", "", "",
   "", "", "", "", "", "Exit Installer", "Enter Installer", "", "", "", "", ""
}, NL = {
   "Geen", "In alarm", "In alarm", "In alarm", "In alarm", "In alarm", 
   "Sabotage alarm", "Systeem sabotage", "Sabotage alarm", "Add user", "Communicate fout", "Paniekalarm",
   "Code bedieningspaneel paniek", "Dwang", "Bevestig alarm", "Successful U/L", "Probleem herstel",
   "Herstel", "Herstel", "Herstel", "Herstel", "Herstel", 
   "Sabotage herstel", "Systeem sabotage herstel", "Sabotage herstel", "Sabotage herstel", "Communicatie herstel",
   "Stop alarm", "Algemeen herstel", "Brand probleem herstel", "Systeem inactief", "Recent close", "Brand", "Brand herstel",
   "Niet actief", "Noodoproep", "Remove user", "Controleer code", "Bevestig alarm", "Supervisie", 
   "Supervisie herstel", "Batterij laag", "Batterij OK", "230VAC uitval", "230VAC herstel",
   "Controlepaneel batterij laag", "Controlepaneel batterij OK", "Radio jamming", "Radio herstel",
   "Communicatie mislukt", "Communicatie hersteld", "Telefoonlijn fout", "Telefoonlijn herstel", 
   "Automatische test", "Zekeringsfout", "Zekering herstel", "Batterij laag", "Batterij OK", "Monteur reset",
   "Accu vermist", "Batterij laag", "Batterij OK", "Supervisie", 
   "Supervisie herstel", "Lage batterij bevestiging", "Reinigen", "Probleem", "Batterij laag", "Batterij OK",
   "230VAC uitval", "230VAC herstel", "Supervisie", "Supervisie herstel", "Gas alarm", "Gas herstel",
   "Gas probleem", "Gas probleem herstel", "Lekkage alarm", "Lekkage herstel", "Probleem", "Probleem herstel", 
   "Deelschakeling", "Ingeschakeld", "Snel deelschakeling", "Snel ingeschakeld", "Uitgezet", "Inschakelfout (auto)", "Test gestart",
   "Test gestopt", "Force aan", "Geheel in (auto)", "Onmiddelijk", "Overbruggen", "Inschakelfout",
   "Log verzenden", "Systeem reset", "Installateur programmeert", "Foutieve code", "Overbruggen"
}}

local pmLogUser_t = {
   "System ", "Zone 01", "Zone 02", "Zone 03", "Zone 04", "Zone 05", "Zone 06", "Zone 07", "Zone 08",
   "Zone 09", "Zone 10", "Zone 11", "Zone 12", "Zone 13", "Zone 14", "Zone 15", "Zone 16", "Zone 17", "Zone 18",
   "Zone 19", "Zone 20", "Zone 21", "Zone 22", "Zone 23", "Zone 24", "Zone 25", "Zone 26", "Zone 27", "Zone 28", 
   "Zone 29", "Zone 30", "Fob  01", "Fob  02", "Fob  03", "Fob  04", "Fob  05", "Fob  06", "Fob  07", "Fob  08", 
   "User 01", "User 02", "User 03", "User 04", "User 05", "User 06", "User 07", "User 08", "Pad  01", "Pad  02",
   "Pad  03", "Pad  04", "Pad  05", "Pad  06", "Pad  07", "Pad  08", "Sir  01", "Sir  02", "2Pad 01", "2Pad 02",
   "2Pad 03", "2Pad 04", "X10  01", "X10  02", "X10  03", "X10  04", "X10  05", "X10  06", "X10  07", "X10  08",
   "X10  09", "X10  10", "X10  11", "X10  12", "X10  13", "X10  14", "X10  15", "PGM    ", "GSM    ", "P-LINK ",
   "PTag 01", "PTag 02", "PTag 03", "PTag 04", "PTag 05", "PTag 06", "PTag 07", "PTag 08" 
}

local pmSysStatus_t = { EN = {
   "Disarmed", "Home Exit Delay", "Away Exit Delay", "Entry Delay", "Armed Home", "Armed Away", "User Test",
   "Downloading", "Programming", "Installer", "Home Bypass", "Away Bypass", "Ready", "Not Ready", "??", "??", 
   "Disarmed Instant", "Home Instant Exit Delay", "Away Instant Exit Delay", "Entry Delay Instant", "Armed Home Instant", 
   "Armed Away Instant"
}, NL = {
   "Uitgeschakeld", "Deel uitloopvertraging", "Totaal uitloopvertraging", "Inloopvertraging", "Deel ingeschakeld",
   "Totaal ingeschakeld", "Gebruiker test", "Downloaden", "Programmeren", "Monteurmode", "Deel met overbrugging",
   "Totaal met overbrugging", "Klaar", "Niet klaar", "??", "??", "Direct uitschakelen", "Direct Deel uitloopvertraging",
   "Direct Totaal uitloopvertraging", "Direct inloopvertraging", "Direct Deel", "Direct Totaal"
}}

local pmSysStatusFlags_t = { 
   EN = {
   "Ready", "Alert in memory", "Trouble", "Bypass on", "Last 10 seconds", "Zone event", "Status changed", "Alarm event"
}, NL = {
   "Klaar", "Alarm in geheugen", "Probleem", "Overbruggen aan", "Laatste 10 seconden", "Zone verstoord", "Status gewijzigd",
   "Alarm actief"
}}

local pmArmed_t = {
   [0x03] = "", [0x04] = "", [0x05] = "", [0x0A] = "", [0x0B] = "", [0x13] = "", [0x14] = "", [0x15] = ""
}

local pmArmMode_t = {
   Disarmed = 0x00, Stay = 0x04, Armed = 0x05, UserTest = 0x06, StayInstant = 0x14, ArmedInstant = 0x15,
   Night = 0x04, NightInstant = 0x14
}

local pmDetailedArmMode_t = {
   "Disarmed", "ExitDelay", "ExitDelay", "EntryDelay", "Stay", "Armed", "UserTest", "NotReady", "NotReady", "NotReady",
   "Force", "Force", "Ready", "NotReady", "??", "??", "Disarmed", "ExitDelay", "ExitDelay", "EntryDelay", "StayInstant",
   "ArmedInstant"
} -- Not used: Night, NightInstant, Vacation

local pmEventType_t = { 
   EN = {
   "None", "Tamper Alarm", "Tamper Restore", "Open", "Closed", "Violated (Motion)", "Panic Alarm", "RF Jamming",
   "Tamper Open", "Communication Failure", "Line Failure", "Fuse", "Not Active", "Low Battery", "AC Failure", 
   "Fire Alarm", "Emergency", "Siren Tamper", "Siren Tamper Restore", "Siren Low Battery", "Siren AC Fail"
}, NL = {
   "Geen", "Sabotage alarm", "Sabotage herstel", "Open", "Gesloten", "Verstoord (beweging)", "Paniek alarm", "RF verstoring",
   "Sabotage open", "Communicatie probleem", "Lijnfout", "Zekering", "Niet actief", "Lage batterij", "AC probleem",
   "Brandalarm", "Noodoproep", "Sirene sabotage", "Sirene sabotage herstel", "Sirene lage batterij", "Sirene AC probleem"
}}

local pmPanelAlarmType_t = {
   [0x01] = "Intruder", [0x02] = "Intruder", [0x03] = "Intruder", [0x04] = "Intruder", [0x05] = "Intruder", [0x06] = "Tamper", 
   [0x07] = "Tamper", [0x08] = "Tamper", [0x09] = "Tamper", [0x0B] = "Panic", [0x0C] = "Panic", [0x20] = "Fire", 
   [0x23] = "Emergency", [0x49] = "Gas", [0x4D] = "Flood"
}

local pmPanelTroubleType_t = {
   [0x0A] = "Communication", [0x0F] = "General", [0x29] = "Battery", [0x2B] = "Power", [0x2D] = "Battery", [0x2F] = "Jamming", 
   [0x31] = "Communication", [0x33] = "Telephone", [0x36] = "Power", [0x38] = "Battery", [0x3B] = "Battery", [0x3C] = "Battery",
   [0x40] = "Battery", [0x43] = "Battery"
}

local pmPanelType_t = {
   [1] = "PowerMax", [2] = "PowerMax+", [3] = "PowerMax Pro", [4] = "PowerMax Complete", [5] = "PowerMax Pro Part",
   [6] = "PowerMax Complete Part", [7] = "PowerMax Express", [8] = "PowerMaster10", [9] = "PowerMaster30"
}

-- Config for each panel type (1-9)
local pmPanelConfig_t = {
   CFG_PARTITIONS = {   1,   1,   1,   1,   3,   3,   1,   3,   3 },
   CFG_EVENTS     = { 250, 250, 250, 250, 250, 250, 250, 250,1000 },
   CFG_KEYFOBS    = {   8,   8,   8,   8,   8,   8,   8,   8,  32 },
   CFG_1WKEYPADS  = {   8,   8,   8,   8,   8,   8,   8,   0,   0 },
   CFG_2WKEYPADS  = {   2,   2,   2,   2,   2,   2,   2,   8,  32 },
   CFG_SIRENS     = {   2,   2,   2,   2,   2,   2,   2,   4,   8 },
   CFG_USERCODES  = {   8,   8,   8,   8,   8,   8,   8,   8,  48 },
   CFG_PROXTAGS   = {   0,   0,   8,   0,   8,   8,   0,   8,  32 },
   CFG_WIRELESS   = {  28,  28,  28,  28,  28,  28,  28,  29,  62 }, -- 30, 64
   CFG_WIRED      = {   2,   2,   2,   2,   2,   2,   1,   1,   2 },
   CFG_ZONECUSTOM = {   0,   5,   5,   5,   5,   5,   5,   5,   5 }
}

local pmPanelSettings_t = { -- PMAX EEPROM CONFIGURATION version 1_2
   -- USER SETTINGS
   usrPhoneNrs   = { count=4, name={"1st Private Tel. No.","2nd Private Tel. No.","3rd Private Tel. No.","4th Private Tel. No."}, 
      type="PHONE", size=64, poff=310, psize=64, pstep=8 }, -- 310, 318, 326, 334
   usrVoice      = { name="Set Voice Option", type="BYTE", size=8, poff=763, psize=8, posvalues={
      [0]="Disable Voice", [1]="Enable Voice"} },
   usrArmOption  = { name="Auto Arm Option", type="BYTE", size=8, poff=280, psize=1, pbitoff=5, posvalues={
      [1]="Enable", [0]="Disable"} },
   usrArmTime    = { name="Auto Arm Time", type="TIME", size=16, poff=765, psize=16 },
   usrSquawk     = { name="Squawk Option", type="BYTE", size=8, poff=764, psize=8, posvalues={
      [0]="Disable", [1]="Low Level", [2]="Medium Level", [3]="High Level"} },
   usrTimeFormat = { name="Time Format", type="BYTE", size=8, poff=281, psize=1, pbitoff=1, posvalues={
      [0]="USA - 12H", [1]="Europe - 24H"} },
   usrDateFormat = { name="Date Format", type="BYTE", size=8, poff=281, psize=1, pbitoff=2, posvalues={
      [0]="USA MM/DD/YYYY", [1]="Europe DD/MM/YYYY"} },
   -- PANEL DEFINITION
   entryDelays   = { count=2, name={"Entry Delay 1","Entry Delay 2"}, type="BYTE", size=8, poff=257, psize=8, pstep=1,
      posvalues={[0]="None", [15]="15 Seconds", [30]="30 Seconds", [45]="45 Seconds", 
      [60]="1 Minute", [180]="3 Minutes", [240]="4 Minutes"} }, -- 257, 258
   exitDelay     = { name="Exit Delay", type="BYTE", size=8, poff=259, psize=8, posvalues={
      [30]="30 Seconds", [60]="60 Seconds", [90]="90 Seconds", [120]="2 Minutes", [180]="3 Minutes", [240]="4 Minutes"} },
   bellTime      = { name="Bell Time", type="BYTE", size=8, poff=260, psize=8, posvalues={
      [1]="1 Minute", [3]="3 Minutes", [4]="4 Minutes", [8]="8 Minutes", [10]="10 Minutes", [15]="15 Minutes", [20]="20 Minutes"} },
   abortTime     = { name="Abort Time", type="BYTE", size=8, poff=267, psize=8, posvalues={
      [0]="None", [15]="15 Seconds", [30]="30 Seconds", [45]="45 Seconds", 
      [60]="1 Minute", [120]="2 Minutes", [180]="3 Minutes", [240]="4 Minutes"} },
   cancelTime    = { name="Alarm Cancel Time", type="BYTE", size=8, poff=266, psize=8, posvalues={
      [1]="1 Minute", [5]="5 Minutes", [15]="15 Minutes", [60]="60 Minutes", [240]="4 Hours", [0]="Inactive"} },
   quickArm      = { name="Quick Arm", type="BYTE", size=8, poff=283, psize=1, pbitoff=3, posvalues={
      [1]="On", [0]="Off"} },
   bypass        = { name="Bypass", type="BYTE", size=8, poff=284, psize=2, pbitoff=6, posvalues={
      [2]="Manual Bypass", [0]="No Bypass", [1]="Force Arm"} },
   exitMode      = { name="Exit Mode", type="BYTE", size=8, poff=282, psize=2, pbitoff=6, posvalues={
      [1]="Restart Exit", [2]="Off by Door", [0]="Normal"} },
   piezoBeeps    = { name="Piezo Beeps", type="BYTE", size=8, poff=261, psize=8, posvalues={
      [2]="Enable", [1]="Off when Home", [0]="Disable"} },
   troubleBeeps  = { name="Trouble Beeps", type="BYTE", size=8, poff=284, psize=2, pbitoff=1, posvalues={
      [3]="Enable", [1]="Off at Night", [0]="Disable"} },
   panicAlarm    = { name="Panic Alarm", type="BYTE", size=8, poff=282, psize=2, pbitoff=4, posvalues={
      [1]="Silent Panic", [2]="Audible Panic", [0]="Disable Panic"} },
   swingerStop   = { name="Swinger Stop", type="BYTE", size=8, poff=262, psize=8, posvalues={
      [1]="After 1 Time", [2]="After 2 Times", [3]="After 3 Times", [0]="No Shutdown"} },
   crossZoning   = { name="Cross Zoning", type="BYTE", size=8, poff=284, psize=1, posvalues={
      [1]="On", [0]="Off"} },
   supervision   = { name="Supevision Interval", type="BYTE", size=8, poff=264, psize=8, posvalues={
      [1]="1 Hour", [2]="2 Hours", [4]="4 Hours", [8]="8 Hours", [12]="12 Hours", [0]="Disable"} },
   notReady      = { name="Not Ready", type="BYTE", size=8, poff=281, psize=1, pbitoff=4, posvalues={
      [0]="Normal", [1]="In Supervision"} },
   fobAux        = { count=2, name={"Auxiliary Keyfob Button function 1","Auxiliary Keyfob Button function 2"},
      type="BYTE", size="8", poff=263, psize=8, pstep=14, posvalues={ -- 263, 277
      [1]="System Status", [2]="Instant Arm", [3]="Cancel Exit Delay", [4]="PGM/X-10"} },
   jamDetect     = { name="Jamming Detection", type="BYTE", size=8, poff=256, psize=8, posvalues={
      [1]="UL 20/20", [2]="EN 30/60", [3]="Class 6", [4]="Other", [0]="Disable"} },
   latchKey      = { name="Latchkey Arming", type="BYTE", size=8, poff=283, psize=1, pbitoff=7, posvalues={
      [1]="On", [0]="Off"} },
   noActivity    = { name="No Activity Time", type="BYTE", size=8, poff=265, psize=8, posvalues={
      [3]="3 Hours", [6]="6 Hours", [12]="12 Hours", [24]="24 Hours", [48]="48 Hours",
      [72]="72 Hours", [0]="Disable"} },
   backLight     = { name="Back Light Time", type="BYTE", size=8, poff=283, psize=1, pbitoff=5, posvalues={
      [1]="Allways On", [0]="Off After 10 Seconds"} },
   duress        = { name="Duress", type="CODE", size=16, poff=273, psize=16 },
   piezoSiren    = { name="Piezo Siren", type="BYTE", size=8, poff=284, psize=1, pbitoff=5, posvalues={
      [1]="On", [0]="Off"} },
   resetOption   = { name="Reset Option", type="BYTE", size=8, poff=270, psize=8, posvalues={
      [1]="Engineer Reset", [0]="User Reset"} },
   tamperOption  = { name="Tamper Option", type="BYTE", size=8, poff=280, psize=1, pbitoff=1, posvalues={
      [1]="On", [0]="Off"} },
   sirenOnLine   = { name="Siren On Line", type="BYTE", size=8, poff=282, psize=1, pbitoff=1, posvalues={
      [1]="Enable on Fail", [0]="Disable on Fail"} },
   memoryPrompt  = { name="Memory Prompt", type="BYTE", size=8, poff=281, psize=1, posvalues={
      [1]="Enable", [0]="Disable", num=0} },
   disarmOption  = { name="Disarm Option", type="BYTE", size=8, poff=281, psize=2, pbitoff=6, posvalues={
      [0]="Any Time", [1]="On Entry All", [2]="On Entry Wireless", [3]="Entry + Away KP"} },
   bellReport    = { name="Bell Report Option", type="BYTE", size=8, poff=283, psize=1, posvalues={
      [1]="EN Standard", [0]="Others"} },
   lowBattery    = { name="Low Battery Acknowledge", type="BYTE", size=8, poff=281, psize=1, pbitoff=3, posvalues={
      [1]="On", [0]="Off"} },
   screenSaver   = { name="Screen Saver", type="BYTE", size=8, poff=269, psize=8, posvalues={
      [2]="Reset By Key", [1]="Reset By Code", [0]="Off"} },
   confirmAlarm  = { name="Confirm Alarm Timer", type="BYTE", size=8, poff=268, psize=8, posvalues={
      [0]="None", [30]="30 Minutes", [45]="45 Minutes", [60]="60 Minutes", [90]="90 Minutes"} },
   acFailure     = { name="AC Failure Report", type="BYTE", size=8, poff=275, psize=8, posvalues={
      [0]="None", [5]="5 Minutes", [30]="30 Minutes", [60]="60 Minutes", [180]="180 Minutes"} },
   userPermit    = { name="User Permit", type="BYTE", size=8, poff=276, psize=8, posvalues={
      [1]="Enable", [0]="Disable"} },
   -- COMMUNICATION SETTINGS
   autotestTime  = { name="Autotest Time", type="TIME", size=16, poff=367, psize=16 },
   autotestCycle = { name="Autotest Cycle", type="BYTE", size=8, poff=369, psize=8, posvalues={
      [1]="1 Day", [4]="5 Days", [2]="7 Days", [3]="30 Days", [0]="Disable"} },
   areaCode      = { name="Area Code", type="CODE", size=24, poff=371, psize=24 },
   outAccessNr   = { name="Out Access Number", type="CODE", size=8, poff=374, psize=8 },
   centralStation= { count=2, name={"1st Central Station (CNTR) Tel. No.", "2nd Central Station (CNTR) Tel. No."}, type="PHONE",
      size=64, poff=288, psize=64, pstep=11 }, -- 288, 299
   accountNo     = { count=2, name={"1st Account No","2nd Account No"}, type="ACCOUNT", size=24, poff=296, psize=24, pstep=11 }, -- 296, 307
   reportFormat  = { name="Report Format", type="BYTE", size=8, poff=363, psize=8, posvalues={
      [0]="Contact ID", [1]="SIA", [2]="4/2 1900/1400", [3]="4/2 1800/2300", [4]="Scancom"} },
   pulseRate     = { name="4/2 Pulse Rate", type="BYTE", size=8, poff=364, psize=8, posvalues={
      [0]="10 pps", [1]="20 pps", [2]="33 pps", [3]="40 pps"} },
   reportCentral = { name="Report to Central Station", type="BYTE", size=8, poff=359, psize=8, posvalues={
      [15]="All * Backup", [7]="All but Open/Close * Backup", [255]="All * All", 
      [119]="All but Open/Close * All but Open/Close", [135]="All but Alert * Alert", 
      [45]="Alarms * All but Alarms", [0]="Disable"} },
   reportConfirm = { name="Report Confirmed Alarm", type="BYTE", size=8, poff=285, psize=2, pbitoff=6, posvalues={
      [0]="Disable Report", [1]="Enable Report", [2]="Enable + Bypass"} },
   send2wv       = { name="Send 2wv Code", type="BYTE", size=8, poff=280, psize=1, pbitoff=6, posvalues={
      [1]="Send", [0]="Don't Send"} },
   voice2Central = { name="Two-Way Voice To Central Stations", type="BYTE", size=8, poff=366, psize=8, posvalues={
      [10]="Time-out 10 Seconds", [45]="Time-out 45 Seconds", [60]="Time-out 60 Seconds",
      [90]="Time-out 90 Seconds", [120]="Time-out 2 Minutes", [1]="Ring Back", [0]="Disable"} },
   ringbackTime  = { name="Ringback Time", type="BYTE", size=8, poff=358, psize=8, posvalues={
      [1]="1 Minute", [3]="3 Minutes", [5]="5 Minutes", [10]="10 Minutes"} },
   csDialAttempt = { name="Central Station Dialing Attempts", type="BYTE", size=8, poff=362, psize=8, posvalues={
      [2]="2", [4]="4", [8]="8", [12]="12", [16]="16"} },
   ringbackNrs   = { count=4, name={"1st Ringback Tel No","2nd Ringback Tel No","3rd Ringback Tel No","4th Ringback Tel No"},
      type="PHONE", size=64, poff=310, psize=64, pstep=8}, -- 310, 318, 326, 334,
   voice2Private = { name="Two-Way Voice - Private Phones", type="BYTE", size=8, poff=283, psize=1, pbitoff=6, posvalues={
      [0]="Disable", [1]="Enable"} },
   privateAttempt= { name="Private Telephone Dialing Attempts", type="BYTE", size=8, poff=365, psize=8, posvalues={
      [1]="1 Attempt", [2]="2 Attempts", [3]="3 Attempts", [4]="4 Attempts"} },
   privateReport = { name="Reporting To Private Tel", type="BYTE", size=8, poff=361, psize=8, posvalues={
      [15]="All", [7]="All but Open/Close", [13]="All but Alerts", [1]="Alarms", 
      [2]="Alerts", [8]="Open/Close", [0]="Disable Report"} },
   privateAck    = { name="Private Telephone Acknowledge", type="BYTE", size=8, poff=285, psize=1, pbitoff=1, posvalues={
      [0]="Single Acknowledge", [1]="All Acknowledge"} },
   pagerNr       = { name="Pager Tel Number", type="PHONE", size=64, poff=342, psize=64 },
   pagerPIN      = { name="Pager PIN #", type="PHONE", size=64, poff=350, psize=64 },
   pagerReport   = { name="Report To Pager", type="BYTE", size=8, poff=360, psize=8, posvalues={
      [15]="All", [3]="All + Alerts", [7]="All but Open/Close", [12]="Troubles+Open/Close",
      [4]="Troubles", [8]="Open/Close", [0]="Disable Report"} },
   recentClose   = { name="Recent Close Report", type="BYTE", size=8, poff=0x11C, psize=1, pbitoff=3, posvalues={
      [1]="On", [0]="Off"} },
   remoteAccess  = { name="Remote Access", type="BYTE", size=8, poff=0x11D, psize=1, pbitoff=2, posvalues={
      [1]="On", [0]="Off"} },
   installerCode = { name="Installer Code", type="CODE", size=0x10, poff=0x20A, psize=0x10 },
   masterCode    = { name="Master Code", type="CODE", size=0x10, poff=0x20C, psize=0x10 },
   masterDlCode  = { name="Master Download Code", type="CODE", size=0x10, poff=0x20E, psize=0x10 },
   instalDlCode  = { name="Installer Download Code", type="CODE", size=0x10, poff=0x210, psize=0x10 },
   zoneRestore   = { name="Zone Restore", type="BYTE", size=8, poff=0x118, psize=1, posvalues={
      [0]="Report Restore", [1]="Don't Report"} },
   uploadOption  = { name="Upload Option", type="BYTE", size=8, poff=0x11A, psize=1, pbitoff=2, posvalues={
      [0]="When System Off", [1]="Any Time"} },
   dialMethod    = { name="Dialing Method", type="BYTE", size=8, poff=0x11D, psize=1, posvalues={
      [0]="Tone (DTMF)", [1]="Pulse"} },
   lineFailure   = { name="Line Failure Report", type="BYTE", size=8, poff=375, psize=8, posvalues={
      [0]="Don't Report", [1]="Immediately", [5]="5 Minutes", [30]="30 Minutes",
      [60]="60 Minutes", [180]="180 Minutes"} },
   remoteProgNr  = { name="Remote Programmer Tel. No.", type="PHONE", size=64, poff=376, psize=64 },
   inactiveReport= { name="System Inactive Report", type="BYTE", size=8, poff=384, psize=8, posvalues={
      [0]="Disable", [180]="7 Days", [14]="14 Days", [30]="30 Days", [90]="90 Days"} },
   ambientLevel  = { name="Ambient Level", type="BYTE", size=8, poff=388, psize=8, posvalues={
      [0]="High Level", [1]="Low Level"} },
   -- GSM DEFINITIONS
   gsmInstall    = { name="GSM Install", type="BYTE", size=8, poff=395, psize=8, posvalues={
      [1]="Installed", [0]="Not Installed"} },
   gsmSmsNrs     = { count=4, name={"1st SMS Number","2nd SMS Number","3rd SMS Number","4th SMS Number"},
      type="PHONE", size=64, poff=396, psize=64, pstep=8 }, -- 396,404,412,420
   gsmSmsReport  = { name="Report to SMS", type="BYTE", size=8, poff=393, psize=8, posvalues={
      [15]="All", [7]="All but Open/Close", [13]="All but Alerts", [1]="Alarms",
      [2]="Alerts", [8]="Open/Close", [0]="Disable Report"} },
   gsmFailure    = { name="GSM Line Failure", type="BYTE", size=8, poff=394, psize=8, posvalues={
      [0]="Don't Report", [2]="2 Minutes", [5]="5 Minutes", [15]="15 Minutes", [30]="30 Minutes"} },
   gsmPurpose    = { name="GSM Line Purpose", type="BYTE", size=8, poff=392, psize=8, posvalues={
      [1]="GSM is Backup", [2]="GSM is Primary", [3]="GSM Only", [0]="SMS Only"} },
   gsmAntenna    = { name="Select GSM antenna", type="BYTE", size=8, poff=447, psize=8, posvalues={
      [0]="Internal antenna", [1]="External antenna", [2]="Auto detect"} },
   -- DEFINE POWERLINK
   plFailure     = { name="PowerLink Failure", type="BYTE", size=8, poff=391, psize=8, posvalues={
      [1]="Report", [0]="Disable Report"} },
   -- PGM DEFINITION
   pgmPulseTime  = { name="Pulse Time", type="BYTE", size=8, poff=681, psize=8, posvalues={
      [2]="2 Seconds", [30]="30 Seconds", [120]="2 Minutes", [240]="4 Minutes"} },
   pgmByArmAway  = { name="By Arm Away", type="BYTE", size=8, poff=537, psize=8, posvalues={
      [0]="Disable", [1]="Turn Off", [2]="Turn On", [3]="Pulse Active"} },
   pgmByArmHome  = { name="By Arm Home", type="BYTE", size=8, poff=553, psize=8, posvalues={
      [0]="Disable", [1]="Turn Off", [2]="Turn On", [3]="Pulse Active"} },
   pgmByDisarm   = { name="By Disarm", type="BYTE", size=8, poff=569, psize=8, posvalues={
      [0]="Disable", [1]="Turn Off", [2]="Turn On", [3]="Pulse Active"} },
   pgmByMemory   = { name="By Memory", type="BYTE", size=8, poff=601, psize=8, posvalues={
      [0]="Disable", [1]="Turn Off", [2]="Turn On", [3]="Pulse Active"} },
   pgmByDelay    = { name="By Delay", type="BYTE", size=8, poff=585, psize=8, posvalues={
      [0]="Disable", [1]="Turn Off", [2]="Turn On", [3]="Pulse Active"} },
   pgmByKeyfob   = { name="By Keyfob", type="BYTE", size=8, poff=617, psize=8, posvalues={
      [0]="Disable", [1]="Turn Off", [2]="Turn On", [3]="Pulse Active", [4]="Toggle"} },
   pgmByLineFail = { name="By Line Fail", type="BYTE", size=8, poff=280, psize=1, pbitoff=2, posvalues={
      [1]="Yes", [0]="No"} },
   pgmZone       = { count=3, name={"Zone A","Zone B","Zone C"}, type="CODE", size=8, poff=697, psize=8, pstep=1 }, -- 697, 698, 699
   pgmActZone    = { count=3, name={"Act Zone A","Act Zone B","Act Zone C"}, type="BYTE", size=8, poff=633, psize=8, pstep=16,
      posvalues={[0]="Disable", [1]="Turn Off", [2]="Turn On", [3]="Pulse Active"} }, -- 633, 649, 665
   -- DEFINE INTERNAL
   intStrobe     = { name="Internal/Strobe Siren", type="BYTE", size=8, poff=283, psize=1, pbitoff=1, posvalues={
      [0]="Internal Siren", [1]="Strobe"} },
   -- X-10 GENERAL DEFINITION
   x10HouseCode  = { name="House Code", type="BYTE", size=8, poff=536, psize=8, posvalues={
      [0]="A", [1]="B", [2]="C", [3]="D", [4]="E", [5]="F", [6]="G", [7]="H", [8]="I", [9]="J", [10]="K", 
      [11]="L", [12]="M", [13]="N", [14]="O", [15]="P"} },
   x10Flash      = { name="Flash On Alarm", type="BYTE", size=8, poff=281, psize=1, pbitoff=5, posvalues={
      [1]="All Lights Flash", [0]="No Flash"} },
   x10Trouble    = { name="Trouble Indication", type="BYTE", size=8, poff=747, psize=8, posvalues={
      [1]="Enable", [0]="Disable"} },
   x10ReportCs1  = { name="Report on Fail to Central Station 1", type="BYTE", size=8, poff=749, psize=1,
      posvalues={[1]="Enable", [0]="Disable"} },
   x10ReportCs2  = { name="Report on Fail to Central Station 2", type="BYTE", size=8, poff=749, psize=1,
      pbitoff=1, posvalues={[1]="Enable", [0]="Disable"} },
   x10ReportPagr = { name="Report on Fail to Pager", type="BYTE", size=8, poff=749, psize=1,
      pbitoff=2, posvalues={[1]="Enable", [0]="Disable"} },
   x10ReportPriv = { name="Report on Fail to Private", type="BYTE", size=8, poff=749, psize=1,
      pbitoff=3, posvalues={[1]="Enable", [0]="Disable"} },
   x10ReportSMS = { name="Report on Fail to SMS", type="BYTE", size=8, poff=749, psize=1,
      pbitoff=4, posvalues={[1]="Enable", [0]="Disable"} },
   x10Lockout   = { name="Lockout Time (start HH:MM)", type="TIME", size=16, poff=532, psize=16 },
   x10Phase     = { name="3 Phase and frequency", type="BYTE", size=8, poff=748, psize=8, posvalues={
      [0]="Disable", [1]="50 Hz", [2]="60 Hz"} },
   -- ZONES
   zoneNameRaw  = { count=31, name="Zone name <x>", type="STRING", size=0x80, poff=0x1900, psize=0x80, pstep=0x10 }
}

local pmPanelName_t = {
   ["0000"] = "PowerMax", ["0001"] = "PowerMax LT", ["0004"] = "PowerMax A", ["0005"] = "PowerMax", ["0006"] = "PowerMax LT",
   ["0009"] = "PowerMax B", ["000a"] = "PowerMax A", ["000b"] = "PowerMax", ["000c"] = "PowerMax LT", ["000f"] = "PowerMax B",
   ["0014"] = "PowerMax A", ["0015"] = "PowerMax", ["0016"] = "PowerMax", ["0017"] = "PowerArt", ["0018"] = "PowerMax SC",
   ["0019"] = "PowerMax SK", ["001a"] = "PowerMax SV", ["001b"] = "PowerMax T", ["001e"] = "PowerMax WSS", ["001f"] = "PowerMax Smith",
   ["0100"] = "PowerMax+", ["0103"] = "PowerMax+ UK (3)", ["0104"] = "PowerMax+ JP", ["0106"] = "PowerMax+ CTA", ["0108"] = "PowerMax+",
   ["010a"] = "PowerMax+ SH", ["010b"] = "PowerMax+ CF", ["0112"] = "PowerMax+ WSS", ["0113"] = "PowerMax+ 2INST", 
   ["0114"] = "PowerMax+ HL", ["0115"] = "PowerMax+ UK", ["0116"] = "PowerMax+ 2INST3", ["0118"] = "PowerMax+ CF", 
   ["0119"] = "PowerMax+ 2INST", ["011a"] = "PowerMax+", ["011c"] = "PowerMax+ WSS", ["011d"] = "PowerMax+ UK", 
   ["0120"] = "PowerMax+ 2INST33", ["0121"] = "PowerMax+", ["0122"] = "PowerMax+ CF", ["0124"] = "PowerMax+ UK",
   ["0127"] = "PowerMax+ 2INST_MONITOR", ["0128"] = "PowerMax+ KeyOnOff", ["0129"] = "PowerMax+ 2INST_MONITOR",
   ["012a"] = "PowerMax+ 2INST_MONITOR42", ["012b"] = "PowerMax+ 2INST33", ["012c"] = "PowerMax+ One Inst_1_44_0",
   ["012d"] = "PowerMax+ CF_1_45_0", ["012e"] = "PowerMax+ SA_1_46", ["012f"] = "PowerMax+ UK_1_47", ["0130"] = "PowerMax+ SA UK_1_48",
   ["0132"] = "PowerMax+ KeyOnOff 1_50", ["0201"] = "PowerMax Pro", ["0202"] = "PowerMax Pro-Nuon ", 
   ["0204"] = "PowerMax Pro-PortugalTelecom", ["020a"] = "PowerMax Pro-PortugalTelecom2", ["020c"] = "PowerMax HW-V9 Pro",
   ["020d"] = "PowerMax ProSms", ["0214"] = "PowerMax Pro-PortugalTelecom_4_5_02", ["0216"] = "PowerMax HW-V9_4_5_02 Pro",
   ["0217"] = "PowerMax ProSms_4_5_02", ["0218"] = "PowerMax UK_DD243_4_5_02 Pro M", ["021b"] = "PowerMax Pro-Part2__2_27",
   ["0223"] = "PowerMax Pro Bell-Canada", ["0301"] = "PowerMax Complete", ["0302"] = "PowerMax Complete_NV",
   ["0303"] = "PowerMax Complete-PortugalTelecom", ["0307"] = "PowerMax Complete_1_0_07", ["0308"] = "PowerMax Complete_NV_1_0_07",
   ["030a"] = "PowerMax Complete_UK_DD243_1_1_03", ["030b"] = "PowerMax Complete_COUNTERFORCE_1_0_06", ["0401"] = "PowerMax Pro-Part",
   ["0402"] = "PowerMax Pro-Part CellAdaptor", ["0405"] = "PowerMax Pro-Part_5_0_08", ["0406"] = "PowerMax Pro-Part CellAdaptor_5_2_04",
   ["0407"] = "PowerMax Pro-Part KeyOnOff_5_0_08", ["0408"] = "PowerMax UK Pro-Part_5_0_08", 
   ["0409"] = "PowerMax SectorUK Pro-Part_5_0_08", ["040a"] = "PowerMax Pro-Part CP1 4_10", ["040c"] = "PowerMax Pro-Part_Cell_key_4_12",
   ["040d"] = "PowerMax Pro-Part UK 4_13", ["040e"] = "PowerMax SectorUK Pro-Part_4_14", ["040f"] = "PowerMax Pro-Part UK 4_15",
   ["0410"] = "PowerMax Pro-Part CP1 4_16", ["0411"] = "PowerMax NUON key 4_17", ["0433"] = "PowerMax Pro-Part2__4_51",
   ["0434"] = "PowerMax UK Pro-Part2__4_52", ["0436"] = "PowerMax Pro-Part2__4_54", ["0437"] = "PowerMax Pro-Part2__4_55 (CP_01)",
   ["0438"] = "PowerMax Pro-Part2__4_56", ["0439"] = "PowerMax Pro-Part2__4_57 (NUON)", ["043a"] = "PowerMax Pro 4_58",
   ["043c"] = "PowerMax Pro 4_60", ["043e"] = "PowerMax Pro-Part2__4_62", ["0440"] = "PowerMax Pro-Part2__4_64",
   ["0442"] = "PowerMax 4_66", ["0443"] = "PowerMax Pro 4_67", ["0444"] = "PowerMax Pro 4_68", ["0445"] = "PowerMax Pro 4_69",
   ["0446"] = "PowerMax Pro-Part2__4_70", ["0447"] = "PowerMax 4_71", ["0449"] = "PowerMax 4_73", ["044b"] = "PowerMax Pro-Part2__4_75",
   ["0451"] = "PowerMax Pro 4_81", ["0452"] = "PowerMax Pro 4_82", ["0454"] = "PowerMax 4_84", ["0455"] = "PowerMax 4_85",
   ["0456"] = "PowerMax 4_86", ["0503"] = "PowerMax UK Complete partition 1_5_00", ["050a"] = "PowerMax Complete partition GPRS",
   ["050b"] = "PowerMax Complete partition NV GPRS", ["050c"] = "PowerMax Complete partition GPRS NO-BBA",
   ["050d"] = "PowerMax Complete partition NV GPRS NO-BBA", ["050e"] = "PowerMax Complete part. GPRS NO-BBA UK_5_14",
   ["0511"] = "PowerMax Pro-Part CP1 GPRS 5_17", ["0512"] = "PowerMax Complete part. BBA UK_5_18", 
   ["0533"] = "PowerMax Complete part2  5_51", ["0534"] = "PowerMax Complete part2 5_52 (UK)", 
   ["0536"] = "PowerMax Complete 5_54 (GR)", ["0537"] = "PowerMax Complete  5_55", ["053a"] = "PowerMax Complete 5_58 (PT)",
   ["053b"] = "PowerMax Complete part2 5_59 (NV)", ["053c"] = "PowerMax Complete  5_60", ["053e"] = "PowerMax Complete 5_62",
   ["053f"] = "PowerMax Complete part2  5_63", ["0540"] = "PowerMax Complete  5_64", ["0541"] = "PowerMax Complete  5_65",
   ["0543"] = "PowerMax Complete  5_67", ["0544"] = "PowerMax Complete  5_68", ["0545"] = "PowerMax Complete  5_69",
   ["0546"] = "PowerMax Complete  5_70", ["0547"] = "PowerMax Complete  5_71", ["0549"] = "PowerMax Complete  5_73",
   ["054b"] = "PowerMax Complete  5_75", ["054f"] = "PowerMax Complete  5_79", ["0601"] = "PowerMax Express",
   ["0603"] = "PowerMax Express CP 01", ["0605"] = "PowerMax Express OEM 6_5", ["0607"] = "PowerMax Express BBA 6_7",
   ["0608"] = "PowerMax Express CP 01 BBA 6_8", ["0609"] = "PowerMax Express OEM1 BBA 6_9", ["060b"] = "PowerMax Express BBA 6_11",
   ["0633"] = "PowerMax Express 6_51", ["063b"] = "PowerMax Express 6_59", ["063d"] = "PowerMax Express 6_61",
   ["063e"] = "PowerMax Express 6_62 (UK)", ["0645"] = "PowerMax Express 6_69", ["0647"] = "PowerMax Express 6_71",
   ["0648"] = "PowerMax Express 6_72", ["0649"] = "PowerMax Express 6_73", ["064a"] = "PowerMax Activa 6_74",
   ["064c"] = "PowerMax Express 6_76", ["064d"] = "PowerMax Express 6_77", ["064e"] = "PowerMax Express 6_78",
   ["064f"] = "PowerMax Secure 6_79", ["0650"] = "PowerMax Express 6_80", ["0650"] = "PowerMax Express part2 M 6_80",
   ["0651"] = "PowerMax Express 6_81", ["0652"] = "PowerMax Express 6_82", ["0653"] = "PowerMax Express 6_83",
   ["0654"] = "PowerMax 6_84", ["0655"] = "PowerMax 6_85", ["0658"] = "PowerMax 6_88", ["0659"] = "PowerMax 6_89",
   ["065a"] = "PowerMax 6_90", ["065b"] = "PowerMax 6_91", ["0701"] = "PowerMax PowerCode-G 7_1", ["0702"] = "PowerMax PowerCode-G 7_2",
   ["0704"] = "PowerMaster10 7_4", ["0705"] = "PowerMaster10 7_05", ["0707"] = "PowerMaster10 7_07", ["070c"] = "PowerMaster10 7_12",
   ["070f"] = "PowerMaster10 7_15", ["0710"] = "PowerMaster10 7_16", ["0711"] = "PowerMaster10 7_17", ["0712"] = "PowerMaster10 7_18",
   ["0713"] = "PowerMaster10 7_19", ["0802"] = "PowerMax Complete PowerCode-G 8_2", ["0803"] = "PowerMaster30 8_3",
   ["080f"] = "PowerMaster30 8_15", ["0810"] = "PowerMaster30 8_16", ["0812"] = "PowerMaster30 8_18", ["0813"] = "PowerMaster30 8_19",
   ["0815"] = "PowerMaster30 8_21"
}

local pmZoneType_t = { 
   EN = {
   "Non-Alarm", "Emergency", "Flood", "Gas", "Delay 1", "Delay 2", "Interior-Follow", "Perimeter", "Perimeter-Follow", 
   "24 Hours Silent", "24 Hours Audible", "Fire", "Interior", "Home Delay", "Temperature", "Outdoor", "16"
}, NL = {
   "Geen alarm", "Noodtoestand", "Water", "Gas", "Vertraagd 1", "Vertraagd 2", "Interieur volg", "Omtrek", "Omtrek volg", 
   "24 uurs stil", "24 uurs luid", "Brand", "Interieur", "Thuis vertraagd", "Temperatuur", "Buiten", "16"
}} -- "Arming Key", "Guard" ??

-- Zone names are taken from the panel, so no language support needed
local pmZoneName_t = {
   "Attic", "Back door", "Basement", "Bathroom", "Bedroom", "Child room", "Closet", "Den", "Dining room", "Downstairs", 
   "Emergency", "Fire", "Front door", "Garage", "Garage door", "Guest room", "Hall", "Kitchen", "Laundry room", "Living room", 
   "Master bathroom", "Master bedroom", "Office", "Upstairs", "Utility room", "Yard", "Custom 1", "Custom 2", "Custom 3",
   "Custom4", "Custom 5", "Not Installed"
}

local pmZoneChime_t = {
   "Off", "Melody", "Zone"
}

-- Note: names need to match to VAR_xxx
local pmZoneSensor_t = {
   [0x3] = "Motion", [0x4] = "Motion", [0x5] = "Magnet", [0x6] = "Magnet", [0x7] = "Magnet", [0xA] = "Smoke", [0xB] = "Gas", 
   [0xC] = "Motion", [0xF] = "Wired"
} -- unknown to date: Push Button, Flood, Universal

local pmZoneSensorMaster_t = {
   [0x01] = { name = "Next PG2", func = "Motion" }, [0x04] = { name = "Next CAM PG2", func = "Camera" },
   [0x16] = { name = "SMD-426 PG2", func = "Smoke" }, [0x2A] = { name = "MC-302 PG2", func = "Magnet" }
}

-- User messages
-- Level 1: direct user feedback
-- Level 2: error messages
-- Level 3: information messages
local pmUserMsg_t = {
   PROG_MODE    = { lvl=1, txt={ EN = "Can only %s if programming is allowed.", NL = "Kan alleen %s als programmeren is toegestaan." }},
   PLNK_MODE    = { lvl=1, txt={ EN = "Can only %s in Powerlink mode.", NL = "Kan alleen %s in Powerlink mode." }},
   DBG_WRITE    = { lvl=2, txt={ EN = "Cannot write to debug file.", NL = "Kan niet schrijven naar debug bestand." }},
   BCKP_WRITE   = { lvl=2, txt={ EN = "Cannot write to backup file.", NL = "Kan niet schrijven naar backup bestand." }},
   BCKP_READ    = { lvl=2, txt={ EN = "Cannot read from backup file.", NL = "Kan niet lezen uit het backup bestand." }},
   BCKP_INVALID = { lvl=2, txt={ EN = "File %s is not a valid PowerMax backup file.", NL = "%s is geen PowerMax backup bestand." }},
   CRASH_WRITE  = { lvl=2, txt={ EN = "Cannot write to crash file.", NL = "Kan niet schrijven naar crash bestand." }},
   TIME_CORRECT = { lvl=3, txt={ EN = "Please correct your time on Vera.", NL = "Corrigeer de Vera tijd." }},
   PANEL_READ   = { lvl=3, txt={ EN = "Reading panel settings...", NL = "Paneel instellingen lezen..." }},
   NOT_STARTING = { lvl=1, txt={ EN = "Plugin not starting due to too many communication errors.", NL = "Plugin start niet. Er zijn teveel communicatiefouten geweest." }},
   SET_IP_PORT  = { lvl=1, txt={ EN = "Please set an IP address and port or select the serial interface for the PowerMax.", NL = "Stel een IP adres en poort in of selecteer een seriële interface." }},
   LOW_TIME_RES = { lvl=2, txt={ EN = "Socket.gettime() is not working. Using low resolution time.", NL = "Socket.gettime() werkt niet. Een lage resolutie tijd wordt nu gebruikt." }},
   ADDING_ZONES = { lvl=3, txt={ EN = "Adding zone devices.", NL = "Zone apparaten toevoegen." }},
   READY_USE    = { lvl=3, txt={ EN = "Ready for use.", NL = "Klaar voor gebruik." }},
   NEED_PIN     = { lvl=1, txt={ EN = "4 digit PIN needed.", NL = "4 cijferige PIN nodig." }},
   NEEDS_PIN    = { lvl=2, txt={ EN = "%s not allowed without PIN.", NL = "%s mag niet zonder pincode." }},
   WRONG_PIN    = { lvl=1, txt={ EN = "Wrong PIN entered.", NL = "Verkeerde pincode ingevoerd." }},
   NOT_ENROLLED = { lvl=2, txt={ EN = "Vera Powerlink not enrolled.", NL = "Vera Powerlink niet aangemeld." }},
   ZONE_TRIPPED = { lvl=3, txt={ EN = "Zone %s tripped.", NL = "Zone %s verstoord." }},
   PANEL_TROUBLE= { lvl=2, txt={ EN = "Trouble - check system.", NL = "Fout. Controleer het systeem." }},
   CALL_USER    = { lvl=3, txt={ EN = "Calling user %s (%s)", NL = "Gebruiker %s wordt gebeld (%s)." }},
   CALL_ACK     = { lvl=3, txt={ EN = "User %s acknowledged by phone.", NL = "Gebruiker %s heeft alarm bevestigd." }},
   QUICK_ARM    = { lvl=1, txt={ EN = "Quick arm mode not enabled in panel settings.", NL = "Snel inschakelen niet mogelijk (zie instellingen)." }},
}

-- Update a system variable only if the value will change
function updateIfNeeded(sid, var, newVal, id, createOnly)
   if (id ~= nil) then
      local curVal = luup.variable_get(sid, var, id)
      local valUpdate = (curVal == nil) or ((createOnly ~= true) and (curVal ~= tostring(newVal)) or false)
      if (valUpdate == true) then
         luup.variable_set(sid, var, newVal, id)
         return true
      end
   end
   return false
end

-- Find child device (Taken from GE Caddx Panel but comes originally from guessed)
function findChild(deviceId, label)
   for k, v in pairs(luup.devices) do
      if (v.device_num_parent == deviceId and v.id == label) then
         return k
      end
   end
end

-- fileExists: check if a device file is available
function fileExists(name, path)
   local s = name .. ".lzo"
   if (path == nil) then
      s = "/etc/cmh-lu/" .. s
   else
      s = path .. s
   end
   local f = io.open(s, "r")
   if (f ~= nil) then
      io.close(f)
      return true
   else
      if (string.find(s, "ludl") == nil) then
         return fileExists(name, "/etc/cmh-ludl/")
      else
         return false
      end      
   end
end

-- Control debug to /var/log/cmh/LuaUPnP.log (taken from GE Caddx Panel)
function debug(s)
   if (pmLogDebug) then
      luup.log("POWERMAX: " .. s)
   end
end

-- pmEncryptPIN
function pmEncryptPIN(pin, decrypt)
	local enc = ""
   if (pmEncryptionKey ~= "") then
      local str = ""
      if (decrypt == true) then
         for i = 0, 3 do
            str = str .. string.char(bitw.band(bitw.rshift(pin, 8 * i), 0xFF))
         end
      elseif (string.len(pin) == 4) then
         str = pin
      else
         str = bitw.rshift(string.byte(pin, 1), 4) .. bitw.band(string.byte(pin, 1), 0x0F)
         str = str .. bitw.rshift(string.byte(pin, 2), 4) .. bitw.band(string.byte(pin, 2), 0x0F)
      end
      for i = 1, #str do
         if (#str >= i or not decrypt) then
            local dist = string.byte(pmEncryptionKey, i % 4 + 1)
            enc = enc .. string.char((string.byte(str, i) - (decrypt and -dist or dist)) % 0xFF)
         end
      end
      if (decrypt == true) then
         enc = string.char(0x10 * (tonumber(string.sub(enc, 1, 1)) or 10) + (tonumber(string.sub(enc, 2, 2)) or 10),
                           0x10 * (tonumber(string.sub(enc, 3, 3)) or 10) + (tonumber(string.sub(enc, 4, 4)) or 10))
      else
         enc = pmString2Dword(enc, 1)
      end
   end
	return enc;
end

-- pmCheckCanProgram
function pmCheckCanProgram(text)
   -- Check Powerlink mode
   if (luup.variable_get(PANEL_SID, "PowerlinkMode", pmPanelDev) == "Powerlink") then
      -- Check encrypted pin
      local pin = luup.variable_get(PANEL_SID, "EnableProgram", pmPanelDev) 
      if (pin ~= nil and pin ~= "") then
         if (tonumber(pin) == pmSettings_t.masterCode) then
            return true
         else
            pmUserMessage("PROG_MODE", text)
         end
      end
   else
      pmUserMessage("PLNK_MODE", text)
   end
   return false
end

-- pmDumpSettings
function pmDumpSettings()
   if (pmLogDebug) then
      local dumpfile = pmSettingsFilename
      local outf = io.open(dumpfile , 'w')
      if (outf == nil) then
         pmUserMessage("DBG_WRITE")
         return false
      end
      debug("Dumping PowerMax settings to file")
      outf:write(string.format("PowerMax settings on %s\n", os.date('%Y-%m-%d %H:%M:%S')))
      for i = 0, 0xFF do
         if (pmRawSettings_t[i] ~= nil) then
            for j = 0, 0x0F do
               local s = ""
               outf:write(string.format("%08X: ", i * 0x100 + j * 0x10))
               for k = 1, 0x10 do
                  local byte = string.byte(pmRawSettings_t[i], j * 0x10 + k)
                  outf:write(string.format(" %02X", byte))
                  s = (byte < 0x20 or (byte >= 0x80 and byte < 0xA0)) and (s .. ".") or (s .. string.char(byte))
               end
               outf:write("  " .. s .. "\n")
            end
         end
      end
      outf:close()
   end
end

-- pmCreateBackup
function pmCreateBackup(filename)
   if (filename == nil or filename == "") then
      filename = "backup"
   end
   filename = pmLogPath .. pmPanelDev .. "_" .. filename .. string.format("_%d.pmb", os.time())
   local outf = io.open(filename , 'w')
   if (outf == nil) then
      pmUserMessage("BCKP_WRITE")
      return false
   end
   debug("Creating backup file " .. filename)
   outf:write(pmBackupMagic) -- magic
   for i = 1, 0xFF do -- don't write page 0
      if (pmRawSettings_t[i] ~= nil) then
         outf:write(string.char(0, i, string.len(pmRawSettings_t[i]) - 1) .. pmRawSettings_t[i]) -- !assumes lentgth alway FF
      end
   end
   outf:close()
   return true, filename
end

-- pmRestoreBackup
function pmRestoreBackup(filename, what)
   if (filename == nil or filename == "") then
      return false
   end
   -- Check if we can read from the file
   local outf = io.open(filename , 'r')
   if (outf == nil) then
      pmUserMessage("BCKP_READ")
      return false
   end
   -- Check if programming is allowed
   if (pmCheckCanProgram() == true) then
      debug("Restoring panel from backup file " .. filename)
      local s = outf:read("*a")
      outf:close()
      if (s ~= nil and string.sub(s, 1, string.len(pmBackupMagic)) == pmBackupMagic) then
         luup.variable_set(PANEL_SID, "PowerlinkMode", "Program", pmPanelDev)
         pmSendMessage("MSG_DOWNLOAD")
         local idx = string.len(pmBackupMagic) + 1
         while (idx < string.len(s)) do
            local offset = string.byte(s, idx)
            local page = string.byte(s, idx + 1)
            local len = string.byte(s, idx + 2) + 1
            debug("Read page " .. page .. " of length " .. len)
            local sub1 = string.sub(s, idx + 3, idx + 0x82)
            local sub2 = string.sub(s, idx + 0x83, idx + len + 1)
            if (what == nil or what[page] ~= nil) then
               -- write page
               pmWriteMessage(page * 0x100 + offset, sub1)
               pmWriteMessage(page * 0x100 + offset + 0x80, sub2)
            end
            idx = idx + len + 3
         end
         pmSendMessage("MSG_EXIT")
      else
         pmUserMessage("BCKP_INVALID", filename)
         return false
      end
   end
end

-- pmGetBackupFiles
function pmGetBackupFiles()
   local t = {}
   local i = 1
   local command = "ls -1t " .. pmLogPath .. pmPanelDev .. "*.pmb"
   local handle = io.popen(command)
   local result = handle:read("*a")
   handle:close()
   for line in string.gmatch(result, "[^\n]+") do
      local tm = tonumber(string.match(line, "_(%d+)%.pmb"))
      if (tm ~= nil) then
         t[i] = { filename = line, datetime = os.date("%F %X", tm) }
         i = i + 1
      end
   end
   t.items = i - 1
   return t
end

-- PDUs can be logged in a file. We use this to discover new never before seen
-- PowerMax messages we need to decode and make sense of in long evenings...
function pmLogPdu(PDU, direction)
   if (pmLogDebug) then
      local logfile = pmLogFilename
      local outf = io.open(logfile , 'a')
      if (outf == nil) then
         pmUserMessage("DBG_WRITE")
         return false
      end
      local filesize = outf:seek("end")
      outf:close()
      -- empty file if it reaches 500 kb
      if (filesize > 500 * 1024) then
         local outf = io.open(logfile , 'w')
         outf:write('')
         outf:close()
      end

      local outf = io.open(logfile, 'a')
      local now = pmTimeFunction()
      outf:write(string.format("%s%s %s %s\n", os.date("%F %X", now), string.gsub(string.format("%.3f", now), "([^%.]*)", "", 1), direction, PDU))
      outf:close()
   end
end

-- pmMessage
local pmLuupTaskHandle = -1
function pmMessage(text, status)
   if (status == nil) then
      luup.task("", 4, nil, -1)
   else
      debug(text)
      pmLuupTaskHandle = luup.task(text, status, "PowerMax", pmLuupTaskHandle)
      if (status == 2) then
         luup.call_delay("pmMessage", 30, "", false)
      end
   end
end

-- pmUserMessage
function pmUserMessage(id, ...)
   local msg = pmUserMsg_t[id]
   if (msg ~= nil) then
      local text = string.format(msg.txt[pmLang], unpack(arg))
      pmMessage(text, 2)
      if (msg.lvl <= pmSpeakLevel and pmImperiHomeDev ~= nil) then
         luup.call_action(IMPERIHOME_SID, "SayTTS", { Text = "PowerMax: " .. text }, pmImperiHomeDev)
      end
   end
end

-- Calculate CRC for PDU send to PowerMax 
function pmCalcCRC(pdu)
   local checksum = 0
   local newPDU
   local len = string.len(pdu)

   assert(len >= 2)
   for i = 2, (len - 2) do
      checksum = checksum + tonumber(string.byte(pdu, i))
   end
   checksum = 0xFF - (checksum % 0xFF)
   if (checksum == 0xFF) then checksum = 0x00 end
   newPDU = string.sub(pdu, 1, len - 2) .. string.char(checksum, 0x0A)
   return newPDU
end

-- Check CRC in PDU received from PowerMax
function pmCheckCRC(pdu)
   local checksum = 0
   local len = string.len(pdu)

   assert(len >= 2)
   for i = 2, (len - 2) do
      checksum = checksum + tonumber(string.byte(pdu, i))
   end
   checksum = 0xFF - (checksum % 0xFF)
   if (checksum == 0xFF) then checksum = 0x00 end
   local got = tonumber(string.byte(pdu, len - 1))
   if (checksum == got) then
      return true
   else
      debug(string.format("CRC check failed (expected %02X, got %02X)", checksum, got))
      return false
   end
end

-- Check whether we're in normal mode or download mode
function pmIsNormalMode()
   local lastType = string.byte(pmLastPDU, 2)
   local normalMode = (lastType >= 0x80) or ((lastType < 0x10) and (string.byte(pmLastPDU, string.len(pmLastPDU) - 2) == 0x43))
   return normalMode
end

-- pmString2Dword: convert 4 characters into an double-word integer
function pmString2Dword(s, start)
   return string.byte(s, start) + 0x100 * string.byte(s, start + 1) + 0x10000 * string.byte(s, start + 2) + 0x1000000 * string.byte(s, start + 3)
end

-- Convert PDU bytes to a string for logging 
function pmPduToString(pdu)
    local PDUstr = ""
    for i = 1, string.len(pdu) do
      PDUstr = PDUstr .. string.format("%02X ", string.byte(pdu, i))
    end
    return PDUstr
end

-- pmHandleCommException: we have run into a communication error
function pmHandleCommException(what)
   local outf = io.open(pmCrashFilename , 'a')
   if (outf == nil) then
      pmUserMessage("CRASH_WRITE")
      return false
   end
   local when = os.date('%x %X')
   outf:write(string.format("Exception %s occurred at %s\n", what, when))
   local exceptions = luup.variable_get(PANEL_SID, "CommExceptions", pmPanelDev)
   if (exceptions == nil) or (tonumber(exceptions) == nil) then
      exceptions = 0
   end
   exceptions = tonumber(exceptions) + 1
   outf:write("Exception count is now " .. exceptions .. "\n")
   luup.variable_set(PANEL_SID, "CommExceptions", exceptions, pmPanelDev)
   luup.variable_set(PANEL_SID, "CommLastException", os.time(), pmPanelDev)
   debug("*** Houston - we have a communication problem (" .. what .. ")! Executing a reload. ***")
   pmExpectedResponse = ""
   pmSendMessage("MSG_INIT")
   -- Check log for a clue & dump it in the crash log
   outf:write("--------------------\n")
   local command = "grep '" .. when .. "' " .. pmLogPath .. "LuaUPnP.log"
   local handle = io.popen(command)
   local result = handle:read("*a")
   handle:close()
   outf:write(result)
   outf:write("--------------------\n")
   local command = "grep -i '^01.*" .. pmPanelDev .. "\\|^01.*powermax' " .. pmLogPath .. "LuaUPnP.log"
   local handle = io.popen(command)
   local result = handle:read("*a")
   handle:close()
   outf:write(result)
   outf:write("--------------------\n")
   outf:close()
   -- Execute a full Reload
   luup.inet.wget("http://localhost/port_3480/data_request?id=lu_reload")
end

-- pmPowerlinkEnrolled
function pmPowerlinkEnrolled()
   pmUserMessage("PANEL_READ")
   luup.variable_set(PANEL_SID, "PowerlinkMode", "Download", pmPanelDev)
   pmSendMessage("MSG_DL", { item = pmDownloadItem_t.MSG_DL_PANELFW })     -- Request the panel FW
   pmSendMessage("MSG_DL", { item = pmDownloadItem_t.MSG_DL_SERIAL })      -- Request serial & type (not always sent by default)
   pmSendMessage("MSG_DL", { item = pmDownloadItem_t.MSG_DL_ZONESTR })     -- Read the names of the zones
   if (pmPowerMaster == true) then
      pmSendMessage("MSG_DL", { item = pmDownloadItem_t.MSG_DL_MR_SIRKEYZON })
   end
   local syncTime = (luup.variable_get(PANEL_SID, "AutoSyncTime", pmPanelDev) ~= "0")
   if (syncTime == true) then
      local t = os.date('*t')
      if (t.year > 2000) then
         local year = t.year - 2000
         local timePdu = string.char(t.sec, t.min, t.hour, t.day, t.month, year)
         pmSyncTimeCheck = t
         pmSendMessage("MSG_SETTIME", { time = timePdu })
      else
         pmUserMessage("TIME_CORRECT")
      end
   end
   pmSendMessage("MSG_START")      -- Start sending all relevant settings please
   pmSendMessage("MSG_EXIT")       -- Exit download mode
end

-- pmIntervalCheck
function pmIntervalCheck(stuff)
   local now = pmTimeFunction()
   -- Check Powerlink keep-alive
   if (pmPowerlinkMode == true) then
      local delta = now - (pmLastKeepAlive or 0)
      debug("Checking last alive message (delta = " .. delta .. ")")
      if (delta > 60) then
         -- Let Powermax know we are alive (and reset Powerlink communication error)
         debug("Clear Powerlink communication error")
         pmSendMessage("MSG_RESTORE")
         pmLastKeepAlive = now
         pmPowerlinkRetry = pmPowerlinkRetry + 1
         if (pmPowerlinkRetry == PL_RETRIES) then
            pmPowerlinkMode = false
            luup.variable_set(PANEL_SID, "PowerlinkMode", "Standard", pmPanelDev)
         end
      end
   end
   -- Check message sending timeout
   local timeout = (now - pmWaitingForResponse > TIMEOUT)
   if (timeout == true) and (pmExpectedResponse ~= "") then
      -- resend last message
      debug("*** Re-sending PDU (got no response) ***")
      if (pmSendMsgRetries == MSG_RETRIES) then
         pmHandleCommException("no response")
      else
         pmSendMsgRetries = pmSendMsgRetries + 1
         pmExpectedResponse = string.sub(pmExpectedResponse, 2)
         pmSendMessage(-1)
      end
   end
   -- Check if a tripped motion sensor has timed out
   for i = 1, 30 do
      local sensor = pmSensorDev_t[i]
      if (sensor ~= nil) then
         local child = sensor['id']
         local motion = (sensor['stype'] == "Motion")
         local lastTrip = luup.variable_get(SECURITY_SID, "LastTrip", child)
         if ((motion == true) and (lastTrip ~= nil)) and (now - lastTrip > (pmMotionOffDelay * 60)) then
            updateIfNeeded(SECURITY_SID, "Tripped", 0, child)
         end
      end
   end
   -- Check Siren
   if (pmSirenActive ~= nil) and (now > pmSirenActive) then
      pmSirenActive = nil
      for i = 1, #pmSirenDev_t do
         luup.variable_set(SIREN_SID, "Status", "0", pmSirenDev_t[i])
      end
   end
   luup.call_timer("pmIntervalCheck", 1, "20s", "", "")
end

-- pmCreateDevice
function pmCreateDevice(deviceList, altid, deviceName, zoneName, zoneType)
   local devVar = "VAR_" .. string.upper(deviceName)
   local devInit = pmDevices_t[devVar]

   assert(devInit ~= nil)
   local setVars = devInit[4]
   
   if (type(altid) == "number") then
      altid = string.format("%s-%d", deviceName, altid)
   elseif (string.sub(altid, 1, 1) == "Z") then
      local wirelessCnt = pmPanelConfig_t.CFG_WIRELESS[pmPanelTypeNr]
      local nr = tonumber(string.sub(altid, 2))
      if (nr > wirelessCnt) then
         setVars = CON_SENSOR_INIT -- wired zone
      end
   end
   if (zoneName == nil) or (zoneName == "") then
      zoneName = altid
   end
   if (zoneType ~= nil) and (zoneType ~= "") then
      zoneName = zoneName .. " (" .. zoneType .. ")"
   else
      zoneName = zoneName .. " (PowerMax)"
   end
   if (fileExists(devInit[2]) == false) then
      debug("File " .. devInit[2] .. " does not exist. Cannot create " .. altid)
      return nil
   else
      pmMessage("Adding " .. deviceName .. " device " .. altid .. " (" .. zoneName .. ")", 4)
      luup.chdev.append(pmPanelDev, deviceList, altid, zoneName, devInit[1], devInit[2], devInit[3], setVars, devInit[5])
      return altid
   end
end

-- Initialises the panel, handlers etc.
function pmStartup(lul_device)
   pmPanelDev = lul_device
   local startTime = socket.gettime()

   -- Initialize UPnP variables
   local sendInit = false
   for i = 1, #pmPanelInit_t do
      local updated = updateIfNeeded(PANEL_SID, pmPanelInit_t[i][1], pmPanelInit_t[i][2], pmPanelDev, pmPanelInit_t[i][3])
      if (i == 1) and (updated == true) then
         sendInit = true
      end
   end

   -- Get log path
   local path = luup.variable_get(PANEL_SID, "LogPath", pmPanelDev)
   if (string.sub(path, string.len(path)) ~= "/") then
      path = path .. "/"
   end
   if (path ~= nil) then
      local f = io.open(path, "r")
      if (f ~= nil) then
         pmLogPath = path
      else
         debug(path .. " does not exist.")
      end
   end
   
   -- Make debug file names device unique
   pmLogFilename = pmLogPath .. string.gsub(pmLogFilename, "<id>", tostring(pmPanelDev))
   pmSettingsFilename = pmLogPath .. string.gsub(pmSettingsFilename, "<id>", tostring(pmPanelDev))
   pmCrashFilename = pmLogPath .. string.gsub(pmCrashFilename, "<id>", tostring(pmPanelDev))

   -- Check if we should start up at all
   local exceptions = luup.variable_get(PANEL_SID, "CommExceptions", pmPanelDev)
   if (exceptions ~= nil) then
      exceptions = tonumber(exceptions, 10)
   end
   if (exceptions ~= nil) and (exceptions > MAX_EXCEPTIONS) then
      local last = luup.variable_get(PANEL_SID, "CommLastException", pmPanelDev)
      local diff = os.difftime(os.time(), last)
      if (diff < 86400) then -- less than a day ago?
         pmUserMessage("NOT_STARTING")
         return false
      else
         -- reset communication error count
         luup.variable_set(PANEL_SID, "CommExceptions", "0", pmPanelDev)
      end
   end

   luup.log("POWERMAX: starting ... device #" .. tostring(pmPanelDev), 10)

   -- Find ImperiHome device
   for key, val in pairs(luup.devices) do
      if (val.device_type == IMPERIHOME_DEV) then
         pmImperiHomeDev = key
      end
   end
   
   -- Check if connected via IP
   local ip = luup.devices[pmPanelDev].ip
   if (ip ~= nil and ip ~= "" and ip ~= "127.0.0.1") then
      local ipaddr, port = string.match(ip, "(.-):(.*)")
      if (port == nil) then
         ipaddr = ip
         port = 80
      end
      debug("IP = " .. ipaddr .. ", port = " .. port)
      luup.io.open(pmPanelDev, ipaddr, tonumber(port))
   end

   -- Check serial port connection
   if (luup.io.is_connected(pmPanelDev) == false) then
      pmUserMessage("SET_IP_PORT")
      updateIfNeeded(HA_DEV_SID, "CommFailure", 1, pmPanelDev)
      return false
   end
   updateIfNeeded(HA_DEV_SID, "CommFailure", 0, pmPanelDev)

   -- Check whether socket.gettime() works reliably; otherwise switch to low resolution mode
   pmTiming = (socket.gettime() ~= startTime) and "high" or "low"
   pmTimeFunction = pmMsgTiming_t[pmTiming].func
   if (pmTiming == "low") then
      pmUserMessage("LOW_TIME_RES")
   end
   
   pmLogDebug = (luup.variable_get(PANEL_SID, "PluginDebug", pmPanelDev) ~= "0")
   local forceStandard = (luup.variable_get(PANEL_SID, "ForceStandard", pmPanelDev) == "1")
   pmLang = luup.variable_get(PANEL_SID, "PluginLanguage", pmPanelDev)
   pmRemoteArm = luup.variable_get(PANEL_SID, "EnableRemoteArm", pmPanelDev)
   pmSensorArm = luup.variable_get(PANEL_SID, "SensorArm", pmPanelDev)
   pmMotionOffDelay = tonumber(luup.variable_get(PANEL_SID, "MotionOffDelay", pmPanelDev), 10)
   
   -- Register all message handlers
   pmReceiveMsg_t[0x02][2] = pmHandleAck
   pmReceiveMsg_t[0x06][2] = pmHandleTimeout
   pmReceiveMsg_t[0x08][2] = pmHandleDenied
   pmReceiveMsg_t[0x0B][2] = pmHandleStop
   pmReceiveMsg_t[0x25][2] = pmHandleDownloadRetry
   pmReceiveMsg_t[0x33][2] = pmHandleSettings
   pmReceiveMsg_t[0x3C][2] = pmHandleInfo
   pmReceiveMsg_t[0x3F][2] = pmHandleSettingsItem
   pmReceiveMsg_t[0xA0][2] = pmHandleEventlog
   pmReceiveMsg_t[0xA3][2] = pmHandleZoneName
   pmReceiveMsg_t[0xA5][2] = pmHandleStatus
   pmReceiveMsg_t[0xA6][2] = pmHandleZoneType
   pmReceiveMsg_t[0xA7][2] = pmHandlePanel
   if (forceStandard == true) then
      pmReceiveMsg_t[0xAB] = nil
   else
      pmReceiveMsg_t[0xAB][2] = pmHandlePowerlink
   end
   pmReceiveMsg_t[0xB0][2] = pmHandlePowerMaster

   -- Register luup web handlers
   luup.register_handler("pmCallbackHandler", "GetEventLog" .. pmPanelDev)
   luup.register_handler("pmCallbackHandler", "GetPanelConfig" .. pmPanelDev)
   luup.register_handler("pmCallbackHandler", "GetBackupFiles" .. pmPanelDev)
   luup.register_handler("pmCallbackHandler", "GetPduLogFile" .. pmPanelDev)
   luup.register_handler("pmCallbackHandler", "GetSettingsFile" .. pmPanelDev)
   luup.register_handler("pmCallbackHandler", "GetCrashFile" .. pmPanelDev)
   luup.register_handler("pmCallbackHandler", "GetLuaLogFile")
   luup.register_handler("pmCallbackHandler", "ValidatePIN" .. pmPanelDev)

   if (sendInit == true) then
      pmSendMessage("MSG_INIT") -- send an init when there is a new plugin version
   end
   
   if (forceStandard == false) then
      pmStartDownload()
   else
      pmProcessSettings()
      luup.variable_set(PANEL_SID, "PowerlinkMode", "Standard", pmPanelDev)
   end
   
   luup.call_timer("pmIntervalCheck", 1, "20s", "", "")
end

-- pmGetPin: Convert a PIN given as string in the PIN PDU format as used in messages to PowerMax
function pmGetPin(pin) 
   local pinPDU

   if (pin == "") or (pin == nil) or (string.len(pin) ~= 4) then
      if (pmPowerlinkMode == true) then
         return pmPincode_t[1], true
      else
         pmUserMessage("NEED_PIN")
         pinPDU = string.char(0x00, 0x00)
         return pinPDU, false
      end
   end
   pinPDU = string.char(tonumber(string.sub(pin, 1, 2), 16), tonumber(string.sub(pin, 3, 4), 16))

   return pinPDU, false
end

-- pmWriteSettings: add a certain setting to the settings table
function pmWriteSettings(page, index, setting)
   local len = string.len(setting)
   local wrap = (index + len - 0x100)
   local sett = { "", "" }
   local i
   assert(len <= 0xB1)
   if (wrap > 0) then
      sett[1] = string.sub(setting, 1, len - wrap)
      sett[2] = string.sub(setting, len - wrap + 1, len + 1)
      wrap = 1
   else
      sett[1] = setting
      wrap = 0
   end
   for i = 0, wrap do
      if (pmRawSettings_t[page + i] == nil) then
         pmRawSettings_t[page + i] = string.rep(string.char(0xFF), 0x100)
      end
      len = string.len(sett[i + 1]) + 1
      if (i == 1) then 
         index = 0 
      end
      pmRawSettings_t[page + i] = string.sub(pmRawSettings_t[page + i], 1, index) .. sett[i + 1] .. string.sub(pmRawSettings_t[page + i], index + len, 0x100)
   end
end

-- pmReadSettings
function pmReadSettings(item)
   local index = string.byte(item, 1) + 1
   local page = string.byte(item, 2)
   local len = string.byte(item, 3) + 0x100 * string.byte(item, 4)
   local s = ""
   if (pmRawSettings_t[page] ~= nil) then
      while (len > 0) do
         local str = string.sub(pmRawSettings_t[page], index, index + len - 1)
         s = s .. str
         page = page + 1
         index = 1
         len = len - string.len(str)
      end
   end
   return s
end

-- pmDecodeConfig
function pmDecodeConfig(addr, item, descr)
   local val = ''
   local page = math.floor(addr / 0x100)
   local pos = addr % 0x100
   if (item.type == "BYTE") then
      local mask = bitw.lshift(1, item.psize) - 1
      local offset = item.pbitoff or 0
      val = bitw.band(bitw.rshift(string.byte(pmRawSettings_t[page], pos + 1), offset), mask)
   elseif (item.type == "PHONE") then
      for j = 1, item.psize / 8 do
         local nr = string.byte(pmRawSettings_t[page], pos + j)
         if (nr ~= 0xFF) then
            val = val .. string.format("%02X", nr)
         end
      end
   elseif (item.type == "TIME") then
      val = string.format("%d:%02d", string.byte(pmRawSettings_t[page], pos + 1), string.byte(pmRawSettings_t[page], pos + 2))
   elseif (item.type == "CODE" or item.type == "ACCOUNT") then
      for j = 1, item.psize / 8 do
         local nr = string.byte(pmRawSettings_t[page], pos + j)
         val = val .. string.format("%02X", nr)
      end
      if (item.type == "CODE" and item.size == 16) then
         val = pmEncryptPIN(val)
      end
   elseif (item.type == "STRING") then
      for j = 1, item.psize / 8 do
         local nr = string.byte(pmRawSettings_t[page], pos + j)
         if (nr ~= 0xFF) then
            val = val .. string.char(nr)
         end
      end
   end
   if (item.type == "BYTE") then
      debug(descr .. ": " .. (item.posvalues[val] or "UNKNOWN") .. " (" .. val .. ")")
   else
      debug(descr .. ": " .. val)
   end
   return val
end

-- pmEncodeConfig
function pmEncodeConfig(addr, item, descr, newVal, write_t)
   debug("Encoding new value " .. newVal .. " for item " .. descr)
   local val, i = ''
   if (item.type == "BYTE") then
      local bit, size = item.pbitoff or 0, item.psize
      local page = math.floor(addr / 0x100)
      local pos = addr % 0x100
      if (write_t[addr] == nil) then
         val = string.byte(pmRawSettings_t[page], pos + 1) -- current value
      else
         val = string.byte(write_t[addr])
      end
      local mask = 0
      for i = bit, bit + size - 1 do
         mask = mask + 2 ^ i
      end
      val = bitw.band(val, 0xFF - mask) -- reset current value
      val = string.char(bitw.bor(val, bitw.lshift(tonumber(newVal), bit)))
   elseif (item.type == "PHONE") then
      for i = 1, string.len(newVal), 2 do
         val = val .. string.char(tonumber(string.sub(newVal, i, i)) * 0x10 + (tonumber(string.sub(newVal, i+1, i+1)) or 0xF))
      end
      val = val .. string.rep(string.char(0xFF), item.size / 8 - string.len(val))
   elseif (item.type == "TIME") then
      local v1, v2 = string.match(newVal, "(%d+):(%2d+)")
      val = string.char(v1, v2)
   elseif (item.type == "CODE" or item.type == "ACCOUNT") then
      if (item.type == "CODE") then
         newVal = pmEncryptPIN(newVal, true)
      end
      for i = 1, string.len(newVal), 2 do
         val = val .. string.char(tonumber(string.byte(newVal, i)) * 0x10 + (tonumber(string.byte(newVal, i + 1)) or 0xF))
      end
   elseif (item.type == "STRING") then
      val = newVal .. string.rep(string.char(0x20), item.size / 8 - string.len(newVal))
   end
   return val
end

-- pmProcessSetting
function pmProcessSettings()
   local i, setting
   local x10_t = {}
   local doorZoneStr = ""
   local motionZoneStr = ""
   local smokeZoneStr = ""
   local deviceStr = ""
   local childDevices = luup.chdev.start(pmPanelDev)
   local autoCreate = (luup.variable_get(PANEL_SID, "AutoCreate", pmPanelDev) == "1")
   local devices = luup.variable_get(PANEL_SID, "Devices", pmPanelDev)

   pmSettings_t.panel = pmPanelSettings_t
   
   local panelSerialType = pmReadSettings(pmDownloadItem_t.MSG_DL_SERIAL)
   if (panelSerialType ~= "") then
      pmEncryptionKey = string.sub(panelSerialType, 1, 4)
      pmPanelTypeNr = string.byte(panelSerialType, 8) + 1
      local model = pmPanelType_t[pmPanelTypeNr] or "UNKNOWN"
      pmSettings_t.model = pmPanelTypeNr
      updateIfNeeded(PANEL_SID, "PanelType", model, pmPanelDev)
      pmDumpSettings()
   end
   
   local zoneCnt = pmPanelConfig_t.CFG_WIRELESS[pmPanelTypeNr] + pmPanelConfig_t.CFG_WIRED[pmPanelTypeNr]
   local customCnt = pmPanelConfig_t.CFG_ZONECUSTOM[pmPanelTypeNr]
   local userCnt = pmPanelConfig_t.CFG_USERCODES[pmPanelTypeNr]
   local partitionCnt = pmPanelConfig_t.CFG_PARTITIONS[pmPanelTypeNr]
   local sirenCnt = pmPanelConfig_t.CFG_SIRENS[pmPanelTypeNr]
   local keypad1wCnt = pmPanelConfig_t.CFG_1WKEYPADS[pmPanelTypeNr]
   local keypad2wCnt = pmPanelConfig_t.CFG_2WKEYPADS[pmPanelTypeNr]
   
   if (pmPowerlinkMode == true) then
      -- Check if time sync was OK
      if (pmSyncTimeCheck ~= nil) then
         setting = pmReadSettings(pmDownloadItem_t.MSG_DL_TIME)
         if (setting ~= "") then
            local timeRead = os.time({ day = string.byte(setting, 4), month = string.byte(setting, 5), year = string.byte(setting, 6) + 2000, 
               hour = string.byte(setting, 3), min = string.byte(setting, 2), sec = string.byte(setting, 1) })
            local timeSet = os.time(pmSyncTimeCheck)
            if (timeRead == timeSet) or (timeRead == timeSet + 1) then
               debug("Time sync OK (" .. os.date("%d/%m/%Y %H:%M:%S", timeRead) .. ")")
            else
               debug("Time sync FAILED (got " .. os.date("%d/%m/%Y %H:%M:%S", timeRead) .. "; expected " .. os.date("%d/%m/%Y %H:%M:%S", timeSet))
            end
         end
      end
      debug("Processing settings information")
      -- Process zone names of this panel
      setting = pmReadSettings(pmDownloadItem_t.MSG_DL_ZONESTR)
      if (setting ~= "") then
         for i = 1, 26 + customCnt do
            local s = string.sub(setting, (i - 1) * 0x10 + 1, i * 0x10):gsub("%s*$", "")
            if (string.byte(s, 1) ~= 0xFF) then
               pmZoneName_t[i] = string.sub(s, 1, 1) .. string.lower(string.sub(s, 2, 0x0F))
               --pmZoneNameRaw_t[i] = s
            end
         end
      end
      -- Process all configuration settings
      for name, item in pairs(pmPanelSettings_t) do
         local addr = item.poff
         if (item.count ~= nil) then
            local tab = {}
            local label = item.name
            for c = 1, item.count do
               local full = label[c]
               if (full == nil) then
                  full = string.gsub(label, "<x>", c)
                  if (c == 1) then
                     pmSettings_t.panel[name].name = {}
                  end
                  pmSettings_t.panel[name].name[c] = full
               end
               tab[c] = pmDecodeConfig(addr, item, name)
               addr = addr + item.pstep
            end
            pmSettings_t[name] = tab
         else
            pmSettings_t[name] = pmDecodeConfig(addr, item, item.name)
         end
      end
      -- Process communication settings
      pmBellTime = pmSettings_t.bellTime or 1
      pmSilentPanic = (pmSettings_t.panicAlarm == 1) or false
      pmQuickArm = (pmSettings_t.quickArm == 1) or false
      pmBypassOff = (pmSettings_t.bypass == 0) or true
      if (pmSensorArm == "auto") then
         pmSensorShowBypass = not(pmBypassOff)
      elseif (pmSensorArm == "bypass") then
         pmSensorShowBypass = true
      elseif (pmSensorArm == "live") then
         pmSensorShowBypass = false
      end
      for i = 1, 4 do
         if (pmSettings_t.ringbackNrs[i] ~= "") then
            pmPhoneNr_t[i] = pmSettings_t.ringbackNrs[i]
         end
      end

      -- Process user pin codes
      if (pmPowerMaster == false) then -- PowerMax models
         setting = pmReadSettings(pmDownloadItem_t.MSG_DL_PINCODES)
      else -- PowerMaster models
         setting = pmReadSettings(pmDownloadItem_t.MSG_DL_MR_PINCODES)
      end
      if (setting ~= "") then
         for i = 1, userCnt do
            pmPincode_t[i] = string.sub(setting, 2 * i - 1, 2 * i)
         end
      end
      -- Process software information
      setting = pmReadSettings(pmDownloadItem_t.MSG_DL_PANELFW)
      if (setting ~= "") then
         local panelEprom = string.sub(setting, 0x01, 0x10)
         local panelSoftware = string.sub(setting, 0x11, 0x20)
         debug(string.format("EPROM: %s; SW: %s", panelEprom, panelSoftware))
         updateIfNeeded(PANEL_SID, "PanelEprom", panelEprom, pmPanelDev)
         updateIfNeeded(PANEL_SID, "PanelSoftware", panelSoftware, pmPanelDev)
         -- Process panel type and serial
         local idx = string.format("%02x%02x", string.byte(panelSerialType, 8), string.byte(panelSerialType, 7))
         local pmPanelName = pmPanelName_t[idx] or "UNKNOWN"
         local pmPanelSerial = ""
         for i = 0, 5 do
            local nr = string.byte(panelSerialType, i + 1)
            local s = (nr == 0xFF) and "." or string.format("%02X", nr)
            pmPanelSerial = pmPanelSerial .. s
         end
         debug(string.format("Panel %s with serial %s", pmPanelName, pmPanelSerial))
         updateIfNeeded(PANEL_SID, "PanelName", pmPanelName, pmPanelDev)
         updateIfNeeded(PANEL_SID, "PanelSerial", pmPanelSerial, pmPanelDev)
      end
      -- Store partition info & check if partitions are on
      local partition = pmReadSettings(pmDownloadItem_t.MSG_DL_PARTITIONS)
      if (partition == "") or (string.byte(partition, 1) == 0) then
         partitionCnt = 1
      end
      -- Process zone settings
      local zoneNames, settingMr
      if (pmPowerMaster == false) then -- PowerMax models
         zoneNames = pmReadSettings(pmDownloadItem_t.MSG_DL_ZONENAMES)
      else -- PowerMaster models
         zoneNames = pmReadSettings(pmDownloadItem_t.MSG_DL_MR_ZONENAMES)
         settingMr = pmReadSettings(pmDownloadItem_t.MSG_DL_MR_ZONES)
      end
      setting = pmReadSettings(pmDownloadItem_t.MSG_DL_ZONES)
      if (setting ~= "") and (zoneNames ~= "") then
         for i = 1, zoneCnt do
            local zoneName = pmZoneName_t[string.byte(zoneNames, i) + 1]
            local zoneEnrolled
            if (pmPowerMaster == false) then  -- PowerMax models
               zoneEnrolled = (string.sub(setting, i * 4 - 3, i * 4 - 1) ~= string.char(0, 0, 0))
            else -- PowerMaster models (check only 5 of 10 bytes)
               zoneEnrolled = (string.sub(settingMr, i * 10 - 5, i * 10 - 1) ~= string.char(0, 0, 0, 0, 0))
            end
            if (zoneEnrolled == true) then
               local zoneInfo, sensorId, sensorType
               if (pmPowerMaster == false) then  -- PowerMax models
                  zoneInfo = string.byte(setting, i * 4)
                  sensorId = string.byte(setting, i * 4 - 1)
                  sensorType = pmZoneSensor_t[bitw.band(sensorId, 0xF)] or "UNKNOWN"
               else -- PowerMaster models
                  zoneInfo = string.byte(setting, i)
                  sensorId = string.byte(settingMr, i * 10 - 4)
                  sensorType = pmZoneSensorMaster_t[sensorId].func or "UNKNOWN"
               end
               zoneType = bitw.band(zoneInfo, 0x0F) + 1
               zoneChime = bitw.band(bitw.rshift(zoneInfo, 4), 0x03) + 1
               local part = {}
               if (partitionCnt > 1) then
                  for j = 1, partitionCnt do
                     if (bitw.band(string.byte(partition, 0x11 + i), 2 ^ (j - 1)) > 0) then
                        table.insert(part, j)
                     end
                  end
               else
                  part = { 1 }
               end
               debug(string.format("Zone %02d: %s (chime = %s; sensor type = %02X [%s])", i, 
                  pmZoneType_t[pmLang][zoneType], pmZoneChime_t[zoneChime], sensorId, sensorType))
               pmSensorDev_t[i] = { stype = sensorType, sid = sensorId, ztype = zoneType, ztypeName = pmZoneType_t[pmLang][zoneType], zname = zoneName, zchime = pmZoneChime_t[zoneChime], partition = part }
               if (sensorType == "Magnet") or (sensorType == "Wired") then
                  doorZoneStr = string.format("%s,Z%02d", doorZoneStr, i)
               elseif (sensorType == "Motion")  or (sensorType == "Camera") then
                  motionZoneStr = string.format("%s,Z%02d", motionZoneStr, i)
               elseif (sensorType == "Smoke") or (sensorType == "Gas") then
                  smokeZoneStr = string.format("%s,Z%02d", smokeZoneStr, i)
               end
            else
               pmSensorDev_t[i] = nil -- remove zone if needed
            end
         end
      end
      -- Process PGM/X10 settings
      setting = pmReadSettings(pmDownloadItem_t.MSG_DL_PGMX10)
      local x10Names = pmReadSettings(pmDownloadItem_t.MSG_DL_X10NAMES)
      if (setting ~= "") and (x10Names ~= "") then
         for i = 0, 15 do
            local enabled = false
            local x10Name = 0x1F
            for j = 0, 8 do
               enabled = enabled or (string.byte(setting, 6 + i + j * 0x10) ~= 0)
            end
            if (i > 0) then
               x10Name = string.byte(x10Names, i)
               x10_t[i] = pmZoneName_t[x10Name + 1]
            end
            if (enabled == true) or (x10Name ~= 0x1F) then
               if (i == 0) then
                  deviceStr = deviceStr .. ",PGM"
               else
                  deviceStr = string.format("%s,X%02d", deviceStr, i)
                  if (string.find(devices, string.format("X%02dd", i)) ~= nil) then
                     deviceStr = deviceStr .. "d"
                  end
               end
            end
         end
      end
      if (pmPowerMaster == false) then
         -- Process keypad settings
         setting = pmReadSettings(pmDownloadItem_t.MSG_DL_1WKEYPAD)
         for i = 1, keypad1wCnt do
            local keypadEnrolled = (string.sub(setting, i * 4 - 3, i * 4 - 2) ~= string.char(0, 0))
            if (keypadEnrolled == true) then
               deviceStr = string.format("%s,K1%d", deviceStr, i)
            end
         end
         setting = pmReadSettings(pmDownloadItem_t.MSG_DL_2WKEYPAD)
         for i = 1, keypad2wCnt do
            local keypadEnrolled = (string.sub(setting, i * 4 - 3, i * 4 - 1) ~= string.char(0, 0, 0))
            if (keypadEnrolled == true) then
               deviceStr = string.format("%s,K2%d", deviceStr, i)
            end
         end
         -- Process siren settings
         setting = pmReadSettings(pmDownloadItem_t.MSG_DL_SIRENS)
         for i = 1, sirenCnt do
            local sirenEnrolled = (string.sub(setting, i * 4 - 3, i * 4 - 1) ~= string.char(0, 0, 0))
            if (sirenEnrolled == true) then
               deviceStr = string.format("%s,S%02d", deviceStr, i)
            end
         end
      else -- PowerMaster
         -- Process keypad settings
         setting = pmReadSettings(pmDownloadItem_t.MSG_DL_MR_KEYPADS)
         for i = 1, keypad2wCnt do
            local keypadEnrolled = (string.sub(setting, i * 10 - 5, i * 10 - 1) ~= string.char(0, 0, 0, 0, 0))
            if (keypadEnrolled == true) then
               deviceStr = string.format("%s,K2%d", deviceStr, i)
            end
         end
         -- Process siren settings
         setting = pmReadSettings(pmDownloadItem_t.MSG_DL_MR_SIRENS)
         for i = 1, sirenCnt do
            local sirenEnrolled = (string.sub(setting, i * 10 - 5, i * 10 - 1) ~= string.char(0, 0, 0, 0, 0))
            if (sirenEnrolled == true) then
               deviceStr = string.format("%s,S%02d", deviceStr, i)
            end
         end
      end
   end

   for i = 1, 1 do -- TODO: partitionCnt
      pmCreateDevice(childDevices, i, "Partition")
      local s = string.format("Partition-%d", i)
      pmPartitionDev_t[i] = findChild(pmPanelDev, s)
   end
   
   pmMessage("Adding zone devices", 4)
   -- Use variables if AutoCreate is false or not in Powerlink mode, otherwise use what we read in the settings
   local doorZones = doorZoneStr
   local motionZones = motionZoneStr
   local smokeZones = smokeZoneStr
   devices = deviceStr
   if (autoCreate == false) or (pmPowerlinkMode == false) then
      doorZones = luup.variable_get(PANEL_SID, "DoorZones", pmPanelDev)
      motionZones = luup.variable_get(PANEL_SID, "MotionZones", pmPanelDev)
      smokeZones = luup.variable_get(PANEL_SID, "SmokeZones", pmPanelDev)
      devices = luup.variable_get(PANEL_SID, "Devices", pmPanelDev)
   elseif (pmPowerlinkMode == true) then
      updateIfNeeded(PANEL_SID, "DoorZones", string.sub(doorZoneStr, 2), pmPanelDev)
      updateIfNeeded(PANEL_SID, "MotionZones", string.sub(motionZoneStr, 2), pmPanelDev)
      updateIfNeeded(PANEL_SID, "SmokeZones", string.sub(smokeZoneStr, 2), pmPanelDev)
      updateIfNeeded(PANEL_SID, "Devices", string.sub(deviceStr, 2), pmPanelDev)
   end
   
   -- Start adding zones
   local zoneName, zoneTypeName
   for i = 1, zoneCnt do
      local s = string.format("Z%02d", i)
      if (pmSensorDev_t[i] ~= nil) then
         zoneName = pmSensorDev_t[i]['zname']
         zoneTypeName = pmZoneType_t[pmLang][pmSensorDev_t[i]['ztype']]
      else
         zoneName = nil
         zoneTypeName = nil
      end
      local stype = nil
      if (string.find(doorZones, s) ~= nil) then
         stype = "Magnet"
      elseif (string.find(motionZones, s) ~= nil) then
         stype = "Motion"
      elseif (string.find(smokeZones, s) ~= nil) then
         stype = "Smoke"
      end
      local sensor = nil
      if (stype ~= nil) then
         sensor = pmCreateDevice(childDevices, s, stype, zoneName, zoneTypeName)
      end
      if (sensor ~= nil) then
         if (pmSensorDev_t[i] == nil) then
            pmSensorDev_t[i] = {}
         end
         pmSensorDev_t[i].id = findChild(pmPanelDev, sensor)
         pmSensorDev_t[i].name = sensor
         pmSensorDev_t[i].stype = stype
         pmSensorDev_t[i].partition = pmSensorDev_t[i].partition or { 1 }
      end
   end
   pmSettings_t.sensors = pmSensorDev_t
   pmSettings_t.maxZones = zoneCnt
   pmSettings_t.maxPartitions = partitionCnt
   pmSettings_t.zoneName = pmZoneName_t
   --pmSettings_t.zoneNameRaw = pmZoneNameRaw_t
   pmSettings_t.zoneType = pmZoneType_t[pmLang]
   --pmSettings_t.panelSettings = pmPanelSettings_t
   
   -- Add PGM and X10 devices
   for i = 0, 15 do
      if (i == 0) then
         s = "PGM"
         if (string.find(devices, s) ~= nil) then
            pmCreateDevice(childDevices, s, "Switch", s)
         end
      else
         s = string.format("X%02d", i)
         local pos = string.find(devices, s)
         if (pos ~= nil) then
            local devInit
            if (string.sub(devices, pos + 3, pos + 3) == "d") then
               pmCreateDevice(childDevices, s, "Dim", x10_t[i], s)
            else
               pmCreateDevice(childDevices, s, "Switch", x10_t[i], s)
            end
         end
      end
      local x10_device = findChild(pmPanelDev, s)
      if (x10_device ~= nil) then
         x10_dev_nr = string.format("%04x", 2 ^ i)
         updateIfNeeded(PANEL_SID, "X10DeviceNr", x10_dev_nr, x10_device, true)
      end
   end
   
   -- Add sirens
   for i = 1, sirenCnt do
      local sirenEnrolled = (string.find(devices, string.format("S%02d", i)) ~= nil)
      if (sirenEnrolled == true) then
         local id = pmCreateDevice(childDevices, i, "Siren")
         if (id ~= nil) then
            pmSirenDev_t[i] = findChild(pmPanelDev, id)
         end
      end
   end

   -- Add keypads
   for i = 1, keypad1wCnt do
      local keypadEnrolled = (string.find(devices, string.format("K1%d", i)) ~= nil)
      if (keypadEnrolled == true) then
         pmCreateDevice(childDevices, i, "Keypad", nil, "1-way")
      end
   end
   
   for i = 1, keypad2wCnt do
      local keypadEnrolled = (string.find(devices, string.format("K2%d", i)) ~= nil)
      if (keypadEnrolled == true) then
         pmCreateDevice(childDevices, i, "Keypad", nil, "2-way")
      end
   end
   luup.chdev.sync(pmPanelDev, childDevices)
   if (pmPowerlinkMode == true) then
      pmSendMessage("MSG_RESTORE") -- also gives status
   else
      pmSendMessage("MSG_STATUS")
      pmSendMessage("MSG_ZONENAME")
      pmSendMessage("MSG_ZONETYPE")
   end
   pmStarting = false
   pmUserMessage("READY_USE")
end

-- pmSendPdu: Send the pdu to the PowerMax via serial
function pmSendPdu(pdu)
   sendPdu = pmCalcCRC(pdu)
   local PDUstr = pmPduToString(sendPdu)
   debug(string.format("PDU sent to panel: %s", PDUstr))
   pmLogPdu(PDUstr, "-VR->")
   if (luup.io.write(sendPdu) == false) then
      luup.log("POWERMAX: cannot send PDU", 2)
      luup.set_failure(true)
      return ""
   end
   return sendPdu
end

-- pmSendAck: Send full or partial acknowledge to Powermax (depending on operating mode)
function pmSendAck(ackType)
   if (pmIsNormalMode() == true) then
      pmSendPdu(string.char(0x0D, ackType, 0x43, 0x00, 0x0A), 0)
   else
      pmSendPdu(string.char(0x0D, ackType, 0x00, 0x0A), 0)
   end
end

-- pmStartDownload
function pmStartDownload()
   if (pmStarting == false) then
      pmStarting = true
      pmSendMessage("MSG_DOWNLOAD")   -- If we get a NACK, then the download code is not valid (not enrolled)
      pmLastKeepAlive = pmTimeFunction()
   else
      debug("Download not started as one is in progress.")
   end
end

-- pmWriteMessage
-- item: address
--   or: DL_xxx
function pmWriteMessage(item, val)
   local len = string.len(val)
   local addr
   if (type(item) == "string") then
      addr = string.sub(pmDownloadItem_t[item], 1, 2)
   else
      addr = string.char(item % 0x100) .. string.char(math.floor(item / 0x100))
   end
   while (len > 0) do
      local s = string.sub(val, 1, 0xB0)
      local l = (len > 0xB0) and 0xB0 or len
      debug(string.format("addr = %02X%02X, len = %02X", string.byte(addr, 2), string.byte(addr), l))
      pmSendMessage("MSG_WRITE", { addr = addr, len = string.char(l), val = s })
      local page = string.byte(addr, 2)
      local index = string.byte(addr)
      pmWriteSettings(page, index, s) -- also update internal table
      len = len - 0xB0
      val = string.sub(val, 0xB1)
      local a = 0x100 * page + index + 0xB0
      addr = string.char(a % 0x100) .. string.char(math.floor(a / 0x100))
   end
end

-- pmSendMessageDelayed
function pmSendMessageDelayed(stuff)
   debug("*** Trigger: delayed sending ***")
   local interval = (pmTimeFunction() - pmWaitingForResponse)
   local wait = (interval <= pmMsgTiming_t[pmTiming].wait)
   if (wait == true) then
      -- not yet 500 ms since last receive; we cannot send yet
      luup.call_delay("pmSendMessageDelayed", pmMsgTiming_t[pmTiming].delay, "")
   else
      pmSendMessage(-2)
   end
end

-- pmSendMessage: Send (known) messages to the PowerMax via serial
-- Returns success: true: sent or queued; false: nothing sent 
function pmSendMessage(msg, modifiers, immediate)
   local outPdu
   local response
   local interval = pmTimeFunction() - pmWaitingForResponse
   local timeout = (interval > TIMEOUT)

   if (msg == -1) then -- re-send last message
      outPdu = pmLastSendMsg
      response = pmExpectedResponse
      timeout = true
   elseif (msg == -2) then -- send message delayed
      outPdu = pmMsgDelayed[1]
      response = pmMsgDelayed[2]
      pmMsgDelayed = nil
      timeout = true
   elseif (msg ~= nil) then
      msg = pmSendMsg_t[msg]
      assert(msg ~= nil)
      outPdu = string.char(0x0D) .. msg[1] .. string.char(0x00, 0x0A)
      response = (msg[2] == nil) and "" or string.char(msg[2])
   
      if (modifiers ~= nil) then
         for fnd, rpl in pairs(modifiers) do
            rpl = string.gsub(rpl, "%%", "%%%%")
            outPdu = string.gsub(outPdu, fnd, rpl, 1)
         end
      end
      
      if (string.byte(outPdu, 2) == 0x3E) then
         local cnt = (string.byte(outPdu, 5)) + 0x100 * string.byte(outPdu, 6)
         response = string.rep(response, math.floor(cnt / 0xB0) + 1)
      end
   end
   
   if (immediate == true) or ((pmMsgDelayed == nil) and ((timeout == true) or (pmExpectedResponse == ""))) then -- we are ready to send
      if (msg == nil) then -- get message from queue
         local tab = Queue.popleft(pmOutgoingQueue)
         if (tab == nil) then
            -- nothing to send
            return false
         end
         outPdu = tab[1]
         response = tab[2]
      end
      -- always expect an ACK (ACK send messages don't pass through here)
      -- check if the last read is at least 500 ms ago
      local wait = (interval <= pmMsgTiming_t[pmTiming].wait)
      if (wait == true) and (immediate ~= true) then
         -- there should be at least 500 ms between last receive and a new send
         debug("*** Send message delayed ***")
         pmMsgDelayed = { outPdu, response }
         luup.call_delay("pmSendMessageDelayed", pmMsgTiming_t[pmTiming].delay, "") -- start new thread
         return true
      end
      pmExpectedResponse = string.char(0x02) .. response
      pmLastPDU = pmSendPdu(outPdu)
      pmLastSendMsg = pmLastPDU
      if (pmLastPDU == "") then
         return false
      end
      pmWaitingForResponse = pmTimeFunction()
   elseif (msg ~= nil) then -- queue message
      Queue.pushright(pmOutgoingQueue, { outPdu, response })
   end
   return true
end

-- A byte of data has been received via serial
-- This function is invoked until a complete PDU is assembled
function pmIncoming(data)
   local pduLen = string.len(pmIncomingPdu)
   local success, ignore

   if (pduLen == 4) and (pmVarLenMsg == true) then
      -- Determine length of variable size message
      local msgType = string.byte(pmIncomingPdu, 2)
      pmIncomingPduLen = pmIncomingPduLen + string.byte(data) + 7
      debug(string.format("Message %02X; pmIncomingPduLen = %d", msgType, pmIncomingPduLen))
   end
   
   if (pduLen == 0) then
      if (string.byte(data) == 0x0D) then -- preamble
         local response = ""
         for i = 1, string.len(pmExpectedResponse) do
            response = response .. string.format(" %02X", string.byte(pmExpectedResponse, i))
         end
         if (response ~= "") then
            response = "; Expecting" .. response
         end
         debug("Start of new PDU detected" .. response)
         pmIncomingPdu = data
      end
   elseif (pduLen == 1) then
		local msgType = string.byte(data)
      local msgType_t = pmReceiveMsg_t[msgType]
      pmIncomingPduLen = (msgType_t ~= nil) and msgType_t[1] or 0
      pmVarLenMsg = (msgType > 0x10) and (msgType_t ~= nil) and (msgType_t[1] == nil)
      debug(string.format("Message %02X; pmIncomingPduLen = %d", string.byte(data), pmIncomingPduLen))
      pmIncomingPdu = pmIncomingPdu .. data
   elseif (pmIncomingPduLen == 0 and string.byte(data) == 0x0A) or (pduLen + 1 == pmIncomingPduLen) then -- postamble
      pmIncomingPdu = pmIncomingPdu .. data
      local msgType = string.byte(pmIncomingPdu, 2)
      if (string.byte(data) ~= 0x0A) and (string.byte(pmIncomingPdu, pduLen) == 0x43) then
         pmIncomingPduLen = pmIncomingPduLen + 1 -- for 0x43
      elseif (pmCheckCRC(pmIncomingPdu) == true) then
         pmLastPDU = pmIncomingPdu
         local PDUstr = pmPduToString(pmIncomingPdu)
         local msgType_t = pmReceiveMsg_t[msgType]
         debug(string.format("PDU received %s", PDUstr))
         pmLogPdu(PDUstr, "<-PM-")
         pmWaitingForResponse = pmTimeFunction()
         
         if (msgType_t == nil) then
            debug(string.format("Unhandled message %02X", msgType))
            pmSendAck(0x02)
         else
            -- Send an ACK if needed
            if (msgType_t[3] == true) then
               pmSendAck(0x02)
            end
            -- Handle the message
            local msgHandler = msgType_t[2] or 0
            local success, ignore = nil, nil
            if (msgHandler == 0) then
               debug(string.format("Unhandled message %02X", msgType))
            else
               success, ignore = msgHandler()
            end
            -- Check response
            if (pmExpectedResponse ~= "") then
               -- We've sent something and are waiting for a reponse - this is it
               local firstExpectedResponse = string.byte(pmExpectedResponse, 1)
               pmExpectedResponse = string.sub(pmExpectedResponse, 2)
               if (firstExpectedResponse ~= msgType) then
                  if (ignore == true) then -- ignore unexpected messages
                     pmExpectedResponse = string.char(firstExpectedResponse) .. pmExpectedResponse
                  elseif (pmSendMsgRetries == 0) then
                     debug(string.format("*** Waiting for next PDU (expected %02X got %02X) ***", firstExpectedResponse, msgType))
                     pmSendMsgRetries = 1 -- don't resend immediately - first wait for the next response
                     pmExpectedResponse = string.char(firstExpectedResponse) .. pmExpectedResponse
                  else
                     debug(string.format("*** Re-sending PDU (expected %02X got %02X) ***", firstExpectedResponse, msgType))
                     if (pmSendMsgRetries == MSG_RETRIES) then
                        pmHandleCommException("wrong response")
                     else
                        pmSendMsgRetries = pmSendMsgRetries + 1
                        pmSendMessage(-1)
                     end
                  end
               else
                  pmSendMsgRetries = 0
               end
            end
         end
         pmIncomingPdu = ""
         if (pmExpectedResponse == "") then
            pmSendMessage(nil)
         end
      else -- CRC check failed
         if (pmIncomingPduLen > 0) then
            local PDUstr = pmPduToString(pmIncomingPdu)
            debug(string.format("PDU with CRC error %s", PDUstr))
            pmLogPdu(PDUstr, "<-PM-")
            pmWaitingForResponse = pmTimeFunction()
            pmIncomingPdu = ""
            if (msgType ~= 0xF1) then -- ignore CRC errors on F1 message
               pmCrcErrorCount = pmCrcErrorCount + 1
            end
            if (pmCrcErrorCount > MAX_CRC_ERROR) then
               pmHandleCommException("CRC errors")
            end
         else
            debug(string.format("Length is now %02X (apparently PDU not complete)", pduLen))
            local PDUstr = pmPduToString(pmIncomingPdu)
            debug(string.format("Partial PDU %s", PDUstr))
         end
      end
   else
      if (pduLen <= 0xC0) then
         pmIncomingPdu = pmIncomingPdu .. data
      else
         local PDUstr = pmPduToString(pmIncomingPdu)
         debug(string.format("Truncating PDU %s", PDUstr))
         pmIncomingPdu = "" -- messages should never be longer than 0xC0
      end
   end
   return true
end

-- pmHandleAck (0x02)
function pmHandleAck()
   local lastSendMsgType = string.byte(pmLastSendMsg, 2)

   if (lastSendMsgType == 0x0F) and (pmReadAllSettings == true) then
      pmPowerlinkMode = true -- we have all info
      luup.variable_set(PANEL_SID, "PowerlinkMode", "Powerlink", pmPanelDev)
      pmProcessSettings()
   end
   return true
end

-- pmHandleTimeout (0x06)
function pmHandleTimeout()
   debug("Powermax sends timeout")
   pmExpectedResponse = string.char(0x06)
   pmSendMessage("MSG_EXIT")
   return true
end

-- pmHandleDenied (0x08)
function pmHandleDenied()
   local lastSendMsgType = string.byte(pmLastSendMsg, 2)
   debug(string.format("Handling DENIED message (%02X)", lastSendMsgType))
   
   if (bitw.band(lastSendMsgType, 0xA0) == 0xA0) then -- A0, A1, AA
      pmUserMessage("WRONG_PIN")
      if (lastSendMsgType == 0xA0) then
         --TODO remove:luup.variable_set(PANEL_SID, "EventLog", "*** Access denied ***", device)
      end
   elseif (lastSendMsgType == 0x24) then
      pmPowerlinkMode = false
      luup.variable_set(PANEL_SID, "PowerlinkMode", "Standard", pmPanelDev)
      pmUserMessage("NOT_ENROLLED")
      pmProcessSettings()
   end
   pmExpectedResponse = string.char(0x08)
   return true
end

-- pmHandleStop (0x0B)
function pmHandleStop()
   -- We're not expecting any more responses
   pmReadAllSettings = true
   pmExpectedResponse = ""
   return true
end

-- pmHandleDownloadRetry (0x25)
function pmHandleDownloadRetry()
   -- Panel is not ready to enter download mode
   local waitTime = string.byte(pmIncomingPdu, 5)
   pmExpectedResponse = string.char(0x25) .. string.sub(pmExpectedResponse, 2)
   pmMsgDelayed = { string.char(0x0D) .. pmSendMsg_t.MSG_DOWNLOAD[1] .. string.char(0x00, 0x0A), string.char(0x3C) }
   luup.call_delay("pmSendMessageDelayed", waitTime, "") -- start new thread
end

-- pmHandleSettings (0x33)
function pmHandleSettings()
   local index = string.byte(pmIncomingPdu, 3)
   local page = string.byte(pmIncomingPdu, 4)
   local lastSendMsgType = string.byte(pmLastSendMsg, 2)
   debug(string.format("Received Powermax setting page %02X index %02X", page, index))
   if (lastSendMsgType == 0x0A) then
      pmExpectedResponse = pmExpectedResponse .. string.char(0x33) -- we're not done; keep them coming
   end
   pmWriteSettings(page, index, string.sub(pmIncomingPdu, 5, 12))
   return true
end

-- pmHandleInfo (0x3C)
function pmHandleInfo()
   pmPanelTypeNr = string.byte(pmIncomingPdu, 8) + 1
   pmPowerMaster = (pmPanelTypeNr >= 8)
   local model = pmPanelType_t[pmPanelTypeNr] or "UNKNOWN"
   debug("Model: " .. model .. "; Nr: " .. pmPanelTypeNr .. "; Master: " .. (pmPowerMaster and "Yes" or "No"))
   updateIfNeeded(PANEL_SID, "PanelType", model, pmPanelDev)
   if (luup.variable_get(PANEL_SID, "PowerlinkMode", pmPanelDev) ~= "Program") then
      pmPowerlinkEnrolled()
   end
   return true
end

-- pmHandleSettingsItem (0x3F)
function pmHandleSettingsItem()
   local idx = string.byte(pmIncomingPdu, 3)
   local page = string.byte(pmIncomingPdu, 4)
   local len = string.byte(pmIncomingPdu, 5)
   debug(string.format("Received Powermax setting page %02X index %02X", page, idx))
   pmWriteSettings(page, idx, string.sub(pmIncomingPdu, 6, 5 + len))
end

-- pmHandleEventlog (0xA0)
function pmHandleEventlog()
   debug(string.format("eventlog received"))
   local eventNum = string.byte(pmIncomingPdu, 4)
   if (eventNum == 0x01) then
      pmEventLog_t = { done = true, items = 0, time = os.date("%F / %X", os.time()) }
      pmEventCnt = string.byte(pmIncomingPdu, 3)
      pmExpectedResponse = pmExpectedResponse .. string.char(0xA0)
   else
      local secNum = string.byte(pmIncomingPdu, 5)
      local minNum = string.byte(pmIncomingPdu, 6)
      local horNum = string.byte(pmIncomingPdu, 7)
      local dayNum = string.byte(pmIncomingPdu, 8)
      local monNum = string.byte(pmIncomingPdu, 9)
      local yerNum = 2000 + string.byte(pmIncomingPdu, 10)
      local eventZone = string.byte(pmIncomingPdu, 11)
      local logEvent = string.byte(pmIncomingPdu, 12)
      local zoneStr = (pmLogUser_t[eventZone + 1] or "UNKNOWN")
      --TODO:if (isPanelEvent == true) then
      --   pmEventLog = pmEventLog .. "  * "
      --else
      --   pmEventLog = pmEventLog .. "    "
      --end
      local eventStr = (pmLogEvent_t[pmLang][logEvent + 1] or "UNKNOWN")
      local idx = eventNum - 1
      pmEventLog_t[idx] = {}
      if (pmPanelConfig_t.CFG_PARTITIONS[pmPanelTypeNr] > 1) then
         local part = 0
         for i = 1, 3 do
            part = (secNum % (2 * i) >= i) and i or part
         end
         pmEventLog_t[idx].partition = (part == 0) and "Panel" or part
         pmEventLog_t[idx].time = string.format("%02d:%02d", horNum, minNum)
      else
         pmEventLog_t[idx].partition = (eventZone == 0) and "Panel" or "1"
         pmEventLog_t[idx].time = string.format("%02d:%02d:%02d", horNum, minNum, secNum)
      end
      pmEventLog_t[idx].date = string.format("%02d/%02d/%d", dayNum, monNum, yerNum)
      pmEventLog_t[idx].zone = zoneStr
      pmEventLog_t[idx].event = eventStr
      pmEventLog_t.items = idx
      pmEventLog_t.done = (eventNum == pmEventCnt)
   end
   return true
end

-- pmHandleStatus (0xA5)
function pmHandleStatus()
   function displaySensorBypass(sensor)
      local armed
      if (pmSensorShowBypass == true) then
         armed = (sensor['bypass'] == true) and 0 or 1
      else
         local zoneType = sensor['ztype'] - 1
         local mode = bitw.band(pmSysStatus, 0x0F)
         armed = ((zoneType > 0) and (sensor['bypass'] ~= true) 
            and ((bitw.band(zoneType, 0x14) == 0) or (mode == 0x5) or ((mode == 0x4) and (zoneType % 6 ~= 0)))) and "1" or "0"
      end
      updateIfNeeded(SECURITY_SID, "Armed", armed, sensor['id'])
   end
   
   local msgTot = string.byte(pmIncomingPdu, 3)
   local eventType = string.byte(pmIncomingPdu, 4)
   --if (msgTot > 0) and (eventType ~= msgTot) then
   --   pmExpectedResponse = pmExpectedResponse .. string.char(0xA5) -- we're not done; keep them coming
   --end
   if (eventType == 0x02) then
      debug("Received zone status message")
      local zoneStatus = pmString2Dword(pmIncomingPdu, 5)
      local batteryStatus = pmString2Dword(pmIncomingPdu, 9)
      for i = 1, 30 do
         local sensor = pmSensorDev_t[i]
         local trip = bitw.band(zoneStatus, 2 ^ (i - 1)) > 0 and 1 or 0
         if (sensor ~= nil) then
            if (updateIfNeeded(SECURITY_SID, "Tripped", trip, sensor['id'])) then
               debug(string.format("Updating tripped status for zone device %02d", i))
            end
            sensor['tripped'] = trip
            local lowBatt = (bitw.band(batteryStatus, 2 ^ (i - 1)) > 0)
            sensor['lowBatt'] = lowBatt
            updateIfNeeded(HA_DEV_SID, "BatteryLevel", lowBatt and 20 or 100, sensor['id'])
         else
            if (trip == 1) then
               debug("Sensor zone " .. i .. " tripped, but no device found!")
            end
         end
      end
   elseif (eventType == 0x04) then
      pmSysStatus     = string.byte(pmIncomingPdu, 5)
      local sysFlags  = string.byte(pmIncomingPdu, 6)
      local eventZone = string.byte(pmIncomingPdu, 7)
      local zoneEType = string.byte(pmIncomingPdu, 8)
      local x10Stat1  = string.byte(pmIncomingPdu, 11)
      local x10Stat2  = string.byte(pmIncomingPdu, 12)

      if (zoneEType ~= 0x00) then
         debug(string.format("Event %s in Zone %02d", (pmEventType_t[pmLang][zoneEType+1] or "UNKNOWN"), eventZone))
         local sensor = pmSensorDev_t[eventZone]
         if (sensor == nil) then
            debug(string.format("unable to locate zone device %02d", eventZone))
         else
            pmUserMessage("ZONE_TRIPPED", sensor['zname'])
            local child = sensor['id']
            if (zoneEType == 0x03) then
               updateIfNeeded(SECURITY_SID, "Tripped", 1, child) -- prevent updating twice; status msg comes before event msg
               luup.variable_set(SECURITY_SID, "LastTrip", os.time(), child)
            elseif (zoneEType == 0x04) then
               updateIfNeeded(SECURITY_SID, "Tripped", 0, child)
            elseif (zoneEType == 0x05) then
               if (updateIfNeeded(SECURITY_SID, "Tripped", 1, child) == true) then
                  luup.variable_set(SECURITY_SID, "LastTrip", os.time(), child)
               end
            end
         end                    
      end

      -- update status of PGM & X10 devices
      local s
      local x10Status = x10Stat1 + (x10Stat2 * 0x100)
      for i = 0, 15 do
         if (i == 0) then
            s = "PGM"
         else
            s = string.format("X%02d", i)
         end
         child = findChild(pmPanelDev, s)
         if (child ~= nil) then
            local status = bitw.band(x10Status, 2 ^ i) > 0 and 1 or 0
            if (updateIfNeeded(X10DEVICE_SID, "Status", status, child) == true) then
               debug("Updating status of X10 device " .. s .. " (status = " .. status .. ")")
            end
         end
      end

      local sysFlagsStr = " "
      if (bitw.band(sysFlags, 1) == 0) then 
         sysFlagsStr = sysFlagsStr .. ",NRDY" 
      end
      if (bitw.band(sysFlags, 2) == 2) then 
         sysFlagsStr = sysFlagsStr .. ",MEM"
         updateIfNeeded(PARTITION_SID, "AlarmMemory", 1, pmPartitionDev_t[1])
      else
         updateIfNeeded(PARTITION_SID, "AlarmMemory", 0, pmPartitionDev_t[1])
      end
      if (bitw.band(sysFlags, 4) == 4) then 
         sysFlagsStr = sysFlagsStr .. ",TRBL"
         pmUserMessage("PANEL_TROUBLE")
      end
      if (bitw.band(sysFlags, 128) == 128) then 
         sysFlagsStr = sysFlagsStr .. ",ALRM" 
         if(updateIfNeeded(PARTITION_SID, "Alarm", "Active", pmPartitionDev_t[1]) == true) then
            luup.variable_set(PARTITION_SID, "LastAlarmActive", os.time(), pmPartitionDev_t[1])
         end
      else
         updateIfNeeded(PARTITION_SID, "Alarm", "None", pmPartitionDev_t[1])
      end
      local armModeNum = (pmArmed_t[pmSysStatus] ~= nil) and 1 or 0
      local armMode = (armModeNum == 1) and "Armed" or "Disarmed"
      local s = ""
      for i = 0, 7 do
         if (bitw.band(sysFlags, 2 ^ i) ~= 0) then
            if (i == 5) then
               if (eventZone == 0xFF) then
                  s = s .. (pmEventType_t[pmLang][zoneEType + 1] or "UNKNOWN") .. " from Panel, "
               else
                  s = s .. string.format("%s in Zone %02d, ", (pmEventType_t[pmLang][zoneEType + 1] or "UNKNOWN"), eventZone)
               end
            else
               s = s .. (pmSysStatusFlags_t[pmLang][i + 1] or "UNKNOWN") .. ", "
            end
         end
      end
      s = (s == "") and "Not ready" or string.sub(s, 1, string.len(s) - 2)
      debug(string.format("System state is %s %s",(pmSysStatus_t[pmLang][pmSysStatus + 1] or "UNKNOWN"), sysFlagsStr))
      updateIfNeeded(PARTITION_SID, "VendorStatus", (pmSysStatus_t[pmLang][pmSysStatus + 1]  or "UNKNOWN") .. sysFlagsStr, pmPartitionDev_t[1])
      updateIfNeeded(PARTITION_SID, "VendorStatusCode", string.format("%02X%02X", pmSysStatus, sysFlags), pmPartitionDev_t[1])
      updateIfNeeded(PARTITION_SID, "VendorStatusData", s, pmPartitionDev_t[1])
      updateIfNeeded(PARTITION_SID, "ArmMode", armMode, pmPartitionDev_t[1])
      updateIfNeeded(PARTITION_SID, "ArmModeNum", armModeNum, pmPartitionDev_t[1])
      updateIfNeeded(PARTITION_SID, "DetailedArmMode", (pmDetailedArmMode_t[pmSysStatus + 1] or "UNKNOWN"), pmPartitionDev_t[1])
      if (pmSensorShowBypass == false) then
         for i = 1, 30 do
            local sensor = pmSensorDev_t[i]
            if (sensor ~= nil) then
               displaySensorBypass(sensor)
            end
         end
      end
   elseif (eventType == 0x06) then
      debug("Received zone bypass message")
      local zoneEnrolled = pmString2Dword(pmIncomingPdu, 5)
      local zoneBypass = pmString2Dword(pmIncomingPdu, 9)
      for i = 1, 30 do
         local enrolled = (bitw.band(zoneEnrolled, 2 ^ (i - 1)) > 0)
         local bypass = (bitw.band(zoneBypass, 2 ^ (i - 1)) > 0)
         local sensor = pmSensorDev_t[i]
         if (sensor ~= nil) then
            sensor['enrolled'] = enrolled
            sensor['bypass'] = bypass
            displaySensorBypass(sensor)
         elseif (enrolled == true) then
            debug("Found zone " .. i .. " to be enrolled while not registered.")
            pmSensorDev_t[i] = {}
            pmSensorDev_t[i].enrolled = enrolled
            pmSensorDev_t[i].bypass = bypass
         end
      end
   end
   return true
end

-- pmHandleZoneName (0xA3)
function pmHandleZoneName()
   local rowCnt = string.byte(pmIncomingPdu, 4)
   for i = 1, 8 do
      local idx = (rowCnt - 1) * 8 + i
      local sensor = pmSensorDev_t[idx]
      if (sensor ~= nil) then
         local zoneName = string.byte(pmIncomingPdu, 4 + i)
         sensor.zname = pmZoneName_t[zoneName + 1]
         debug("Adding zone name " .. sensor.zname .. " for zone " .. idx)
      end
   end
   return true
end

-- pmHandleZoneType (0xA6)
function pmHandleZoneType()
   local rowCnt = string.byte(pmIncomingPdu, 4)
   for i = 1, 8 do
      local idx = (rowCnt - 1) * 8 + i
      local sensor = pmSensorDev_t[idx]
      if (sensor ~= nil) then
         local zoneInfo = string.byte(pmIncomingPdu, 4 + i) - 0x1E
         local zoneType = bitw.band(zoneInfo, 0x0F) + 1
         sensor.ztype = zoneType 
         sensor.ztypeName = pmZoneType_t[pmLang][zoneType]
         debug("Adding zone type " .. sensor.ztypeName .. " for zone " .. idx)
      end
   end
   return true
end

-- pmHandlePanel (0xA7)
function pmHandlePanel()
   local i
   local msgCnt = string.byte(pmIncomingPdu, 3)
   for i = 1, msgCnt do
      local eventZone = string.byte(pmIncomingPdu, 3 + 2 * i)
      local logEvent  = string.byte(pmIncomingPdu, 4 + 2 * i)
      local eventType = bitw.band(logEvent, 0x7F)
      local s = (pmLogEvent_t[pmLang][eventType + 1] or "UNKNOWN") .. " / " .. (pmLogUser_t[eventZone + 1] or "UNKNOWN")
      debug("System message: " .. s)
      local alarmStatus = pmPanelAlarmType_t[eventType] or "None"
      local troubleStatus = pmPanelTroubleType_t[eventType] or "None"
      luup.variable_set(PANEL_SID, "PanelStatusCode", string.format("%02X", logEvent), pmPanelDev)
      luup.variable_set(PANEL_SID, "PanelStatusData", s, pmPanelDev)
      luup.variable_set(PANEL_SID, "PanelAlarmType", alarmStatus, pmPanelDev)
      luup.variable_set(PANEL_SID, "PanelTroubleType", troubleStatus, pmPanelDev)
      --luup.variable_set(PARTITION_SID, "LastUser", pmLogUser_t[eventZone + 1], pmPartitionDev_t[1])
      -- Update siren status
      local noSiren = ((eventType == 0x0B) or (eventType == 0x0C)) and (pmSilentPanic == true)
      if (alarmStatus ~= "None") and (eventType ~= 0x04) and (noSiren == false) then
         for i = 1, #pmSirenDev_t do
            luup.variable_set(SIREN_SID, "Status", "1", pmSirenDev_t[i])
         end
         pmSirenActive = pmTimeFunction() + 60 * pmBellTime
      end
      if (eventType == 0x1B) and (pmSirenActive ~= nil) then -- Cancel Alarm
         pmSirenActive = nil
         for i = 1, #pmSirenDev_t do
            luup.variable_set(SIREN_SID, "Status", "0", pmSirenDev_t[i])
         end
      end
      if (eventType == 0x60) then -- System reset
         pmStartDownload()
      end
   end
   return true, true -- A7 always unexpected
end

-- pmHandlePowerlink (0xAB)
function pmHandlePowerlink()
   local subType = string.byte(pmIncomingPdu, 3)
   if (subType == 0x03) then -- keepalive message
      pmSendAck(0x02)
      if (pmPowerlinkMode == false) then
         debug("Got alive message while not in Powerlink mode; starting download")
         pmStartDownload()
      end
      pmLastKeepAlive = pmTimeFunction()
      pmPowerlinkRetry = 0
      return true, true -- ignore alive message for expected response (never expected)
   elseif (subType == 0x05) then -- phone message
      local action = string.byte(pmIncomingPdu, 5)
      if (action == 1) then
         pmUserMessage("CALL_USER", pmUserCalling, pmPhoneNr_t[pmUserCalling])
         pmUserCalling = pmUserCalling + 1
         if (pmUserCalling > #pmPhoneNr_t) then
            pmUserCalling = 1
         end
      elseif (action == 2) then
         pmUserMessage("CALL_ACK", pmUserCalling)
         pmUserCalling = 1
      end
      pmSendAck(0x02)
   elseif (subType == 0x0A and string.byte(pmIncomingPdu, 5) == 0x01) then
      debug("Enrolling Powerlink")
      pmSendMessage("MSG_ENROLL", nil, true)
      pmExpectedResponse = string.char(0xAB, 0x02, 0xA5) .. string.sub(pmExpectedResponse, 2)
   else
      pmSendAck(0x02)
   end
   return true
end

-- pmHandlePowerMaster (0xB0)
function pmHandlePowerMaster()
   local msgSubTypes = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 
      0x18, 0x19, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x24, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x38, 0x39, 0x3A }
   local msgType = string.byte(pmIncomingPdu, 3) -- 00, 01, 04: req; 03: reply, so expecting 0x03
   local subType = string.byte(pmIncomingPdu, 4)
   local msgLen = string.byte(pmIncomingPdu, 5)
   debug(string.format("Received PowerMaster message %02X/%02X (len = %02X)", msgType, subType, msgLen))
   return true
end

-- RequestArmMode
function RequestArmMode(state, pin)
   local pinPDU, isPL = pmGetPin(pin)
   local armCode = pmArmMode_t[state]
   local allowed = true
   
   debug("RequestArmMode " .. (state or "N/A"))
   if (armCode ~= nil) then
      if (pmRemoteArm == "false") then
         allowed = false
      elseif (pmRemoteArm == "arm") then
         allowed = (bitw.band(armCode, 0x5) == 0x5)
      elseif (pmRemoteArm == "stay") then
         allowed = (bitw.band(armCode, 0x5) ~= 0)
      else
         allowed = true
      end
      if (allowed == true) or (isPL == false) then
         pmSendMessage("MSG_ARM", { arm = string.char(armCode), pin = pinPDU })
      else
         pmUserMessage("NEEDS_PIN", (state or "N/A"))
      end
   else
      debug(string.format("RequestArmMode invalid state requested " .. (state or "N/A")))
   end
end

-- RequestQuickArmMode
function RequestQuickArmMode(DetailedArmMode)
   debug("RequestQuickArmMode " .. (state or "N/A"))

   if (DetailedArmMode == "Stay") or (DetailedArmMode == "Armed") then
      if (pmPowerlinkMode == true) and (pmQuickArm == false) then
         pmUserMessage("QUICK_ARM")
      else
         RequestArmMode(DetailedArmMode, string.char(0, 0))
      end
   else
      pmMessage("RequestQuickArmMode only possible for Arm or Stay.", 2)
   end
end

-- SetArmed
function SetArmed(device, newArmedValue)
   if (pmPowerlinkMode == true) then
      if (pmBypassOff == false) then
         local zone = tonumber(string.sub(luup.devices[device].id, 2))
         local bypass = string.format("%08X", 2 ^ (zone - 1))
         local bypassStr = ""
         for i = 0, 3 do
            bypassStr = bypassStr .. string.char("0x" .. string.sub(bypass, 7 - i * 2, 8 - i * 2))
         end
         if (newArmedValue == "1") then
            pmSendMessage("MSG_BYPASSDIS", { pin = pmPincode_t[1], bypass = bypassStr })
         elseif (newArmedValue == "0") then
            pmSendMessage("MSG_BYPASSEN", { pin = pmPincode_t[1], bypass = bypassStr })
         end
         pmSendMessage("MSG_BYPASSTAT") -- request status to check success and update variable
      else
         pmMessage("Bypass option not enabled in panel settings.", 2)
      end
   else
      pmMessage("Bypass setting only supported in Powerlink mode.", 2)
   end
end

-- SetTarget
function SetTarget(device, DeviceID, newTargetValue)
   -- Two ways to call this function
   -- 1. Using lul_device (don't set 'DeviceID')
   -- 2. Setting 'DeviceID' to the X10 nr (e.g. 7 for X07)
   if (DeviceID ~= nil) then
      local s = (DeviceID == 0) and "PGM" or string.format("X%02d", DeviceID)
      local child = findChild(pmPanelDev, s)
      if (child == nil) then
         debug(string.format("Unable to locate device X%02d", DeviceID))
         return false
      else
         device = child
      end
   end
   local altid = luup.devices[device].id
   local device_nr = luup.variable_get(PANEL_SID, "X10DeviceNr", device)
   if (device_nr ~= nil) then
      local onoff = newTargetValue or 0
      local x10dev = string.char(tonumber(string.sub(device_nr, 3, 4),16)) .. string.char(tonumber(string.sub(device_nr, 1, 2),16))
      debug("Turn X10 device on/off (" .. onoff .. "/" ..  device_nr ..")")
      luup.variable_set(X10DEVICE_SID, "Target", onoff, device)
      pmSendMessage("MSG_X10PGM", { cmd = string.char(onoff), device = x10dev })
      -- If it went OK, we will receive an A5 status from the PowerMax, which will update the X10 status
   elseif (pmPowerlinkMode == true) and (string.find(altid, "Siren") ~= nil) and (newTargetValue == "0") then -- Turn sirens off
      pmSirenActive = nil
      pmSendMessage("MSG_ARM", { arm = string.char(0x0B), pin = pmPincode_t[1] })
      for i = 1, #pmSirenDev_t do
         updateIfNeeded(SIREN_SID, "Status", "0", pmSirenDev_t[i])
      end
   end
end

-- GetTarget
function GetTarget(device, Target)
   luup.variable_set(X10DEVICE_SID, "RetTargetValue", Target, device)
end

-- GetStatus
function GetStatus(device, Status)
   luup.variable_set(X10DEVICE_SID, "ResultStatus", Status, device)
end

-- SetLoadLevelTarget
function SetLoadLevelTarget(device, newLoadlevelTarget)
   local device_nr = luup.variable_get(PANEL_SID, "X10DeviceNr", device)
 
   if (device_nr ~= nil) then
      local current = luup.variable_get(X10DEVICEDIM_SID, "LoadLevelTarget", device) or 0
      debug("Dimming X10 device (" .. newLoadlevelTarget .. "/" ..  device_nr ..")")

      local cmd = nil
      current = tonumber(current)
      if (newLoadlevelTarget == "0") then
         SetTarget(device, nil, 0)
         luup.variable_set(X10DEVICEDIM_SID, "LoadLevelTarget", "0", device)
         luup.variable_set(X10DEVICEDIM_SID, "LoadLevelStatus", "0", device) -- TODO: only after ACK
      elseif (newLoadlevelTarget == "100") then
         SetTarget(device, nil, 1)
         luup.variable_set(X10DEVICEDIM_SID, "LoadLevelTarget", "100", device)
         luup.variable_set(X10DEVICEDIM_SID, "LoadLevelStatus", "100", device) -- TODO: only after ACK
      elseif (tonumber(newLoadlevelTarget) > current) then
         cmd = 0x0B -- bright
         current = (current < 90) and (current + 10) or 100
      elseif (tonumber(newLoadlevelTarget) < current) then
         cmd = 0x0A -- dim
         current = (current > 10) and (current - 10) or 0
      end
      if (cmd ~= nil) then
         luup.variable_set(X10DEVICEDIM_SID, "LoadLevelTarget", current, device)
         luup.variable_set(X10DEVICEDIM_SID, "LoadLevelStatus", current, device) -- TODO: only after ACK
         local x10dev = string.char(tonumber(string.sub(device_nr, 3, 4),16)) .. string.char(tonumber(string.sub(device_nr, 1, 2),16))
         pmSendMessage("MSG_X10PGM", { cmd = string.char(cmd), device = x10dev })
         pmSendMessage("MSG_X10PGM", { cmd = string.char(cmd), device = x10dev }) -- send it twice (step by 10%)
      end
   end
end

-- GetLoadLevelTarget
function GetLoadLevelTarget(device, Target)
   luup.variable_set(X10DEVICEDIM_SID, "GetLoadlevelTarget", Target, device)
end

-- GetLoadLevelStatus
function GetLoadLevelStatus(device, Status)
   luup.variable_set(X10DEVICEDIM_SID, "retLoadlevelStatus", Status, device)
end

-- ToggleState
function ToggleState(device)
   local lul_arguments = {}
   local onoff = luup.variable_get(X10DEVICE_SID, "Status", device) or 0
   lul_arguments["newTargetValue"] = 1 - onoff
   lul_resultcode, lul_resultstring, lul_job, lul_returnarguments = luup.call_action(X10DEVICE_SID, "SetTarget", lul_arguments, device)
end

-- GetEventLog
function GetEventLog(device, PINCode)
   debug("GetEventLog")
   pmSendMessage("MSG_EVENTLOG", { pin = pmGetPin(PINCode) })
end

-- ProgramZones
function ProgramZones(device, configuration)
   function replaceChar(str, idx, rep)
      local pat
      rep = string.char(rep)
      if (idx == 1) then
         pat = "^.(.*)$"
         return string.gsub(str, pat, rep .. "%1") -- %1 because in this case there is only one capture
      else
         pat = "^(" .. ("."):rep(idx - 1) .. ").(.*)$"
         return string.gsub(str, pat, "%1" .. rep .. "%2")
      end
   end
   
   debug("ProgramZones")
   if (pmCheckCanProgram("program zones") == true) then
      local t = json2Table(configuration)
      local powerMaster = (pmPanelTypeNr >= 8)
      local zoneNames
      if (powerMaster == false) then -- PowerMax models
         zoneNames = pmReadSettings(pmDownloadItem_t.MSG_DL_ZONENAMES)
      else -- PowerMaster models
         zoneNames = pmReadSettings(pmDownloadItem_t.MSG_DL_ZONENAMES_MASTER)
      end
      local partitions = pmReadSettings(pmDownloadItem_t.MSG_DL_PARTITIONS)
      local settings = pmReadSettings(pmDownloadItem_t.MSG_DL_ZONES)
      for i = 1, pmSettings_t.maxZones do
         local elem = t[tostring(i)]
         if (elem ~= nil) then
            local ztype = tonumber(elem.ztypeName)
            local zname = tonumber(elem.zname)
            local partition = tonumber(elem.partition)
            local zchime = tonumber(elem.zchime)
            debug("Zone " .. i .. ": Type " .. pmZoneType_t[pmLang][ztype+1] .. ", Name " .. pmZoneName_t[zname+1].. ", Chime " .. pmZoneChime_t[zchime+1])
            local idx = (powerMaster == true) and i or (i * 4)
            local zoneInfo = ztype + bitw.lshift(zchime, 4)
            debug(string.format("Zone type Read: %02X - Write: %02X", string.byte(settings, idx), zoneInfo))
            settings = replaceChar(settings, idx, zoneInfo)
            debug(string.format("Zone name Read: %02X - Write: %02X", string.byte(zoneNames, i), zname))
            zoneNames = replaceChar(zoneNames, i, zname)
            if (partition ~= nil) then
               debug(string.format("Partition Read: %02X - Write: %02X", string.byte(partitions, 0x11 + i) , partition + 1))
               partitions = replaceChar(partitions, 0x11 + i, partition + 1)
            end
         end
      end
      -- Data assembled, we can start writing
      luup.variable_set(PANEL_SID, "PowerlinkMode", "Program", pmPanelDev)
      pmSendMessage("MSG_DOWNLOAD")
      pmWriteMessage("MSG_DL_ZONES", settings)
      pmWriteMessage((powerMaster == false) and "MSG_DL_ZONENAMES" or "MSG_DL_ZONENAMES_MASTER", zoneNames)
      if (partitions ~= nil) then
         pmWriteMessage("MSG_DL_PARTITIONS", partitions)
      end
      pmSendMessage("MSG_EXIT")
   end
end

-- ProgramConfig
function ProgramConfig(device, configuration)
   debug("ProgramConfig")
   if (pmCheckCanProgram("program panel configuration") == true) then
      local t = json2Table(configuration)
      local newItems, cnt = {}, 1
      for key, val in pairs(t) do
         local conf = pmPanelSettings_t[key]
         if (conf ~= nil) then
            debug("Found " .. key .. " in settings table")
            if (type(val) == 'table') then
               local val_t, addr, i = val
               for i, val in pairs(val_t) do
                  addr = conf.pstep * (i - 1) + conf.poff
                  if (tostring(pmDecodeConfig(addr, conf, key)) ~= val) then
                     newItems[addr] = pmEncodeConfig(addr, conf, key, val, newItems)
                     cnt = cnt + 1
                  end
               end
            elseif (tostring(pmDecodeConfig(conf.poff, conf, key)) ~= val) then
               newItems[conf.poff] = pmEncodeConfig(conf.poff, conf, key, val, newItems)
               cnt = cnt + 1
            end
         else
            debug("Could not find " .. key .. " in settings table")
         end
      end
      if (cnt > 1) then
         -- Data assembled, we can start writing
         luup.variable_set(PANEL_SID, "PowerlinkMode", "Program", pmPanelDev)
         pmSendMessage("MSG_DOWNLOAD")
         debug("Writing updated configuration items")
         for addr, data in pairs(newItems) do
            pmWriteMessage(addr, data)
         end
         pmSendMessage("MSG_EXIT")
      end
   end
end

-- function CreateBackup
function CreateBackup(device, filename)
   assert(tonumber(device) == pmPanelDev)
   if (luup.variable_get(PANEL_SID, "PowerlinkMode", pmPanelDev) == "Powerlink") then
      pmCreateBackup(filename)
   else
      pmMessage("Can only create backup in Powerlink mode", 2)
   end
end

-- function RestoreBackup
function RestoreBackup(device, filename, what)
   assert(tonumber(device) == pmPanelDev)
   if (pmCheckCanProgram("restore backup") == true) then
      pmRestoreBackup(filename, nil) -- TODO: nil -> what
   end
end

-- json2Table: converts json format to a lua table
-- Note: very limited - only handles json string objects
function json2Table(o)
   local t, key, val, i, ix = {}, {}, nil, 1, 0
   while (o ~= '') do
      local c = string.sub(o, 1, 1)
      local cnt = 1
      if (c == '{') then
         ix = ix + 1
         t[ix] = {}
      elseif (c == '}' and key[ix] ~= '') then
         t[ix][key[ix]] = val
         ix = ix - 1
         t[ix][key[ix]] = t[ix + 1]
         key[ix], t[ix + 1] = '', {}
      elseif (c == '"') then
      	 val = string.match(o, '\"(.-)\"')
      	 cnt = string.len(val) + 2
      elseif (c == ':') then
         key[ix] = val
         val = nil
  	  elseif (c == ',' and key[ix] ~= '' and val ~= nil) then
         t[ix][key[ix]] = val
  	     key[ix] = ''
      end
      o = string.sub(o, 1 + cnt)
      i = i + cnt
   end
   return t[1]
end

-- table2Json: converts a lua table to json format
function table2Json(o)
   if type(o) == 'table' then
      local s = '{ '
      if (next(o) == nil) then
         s = '{}'
      else
         for k, v in pairs(o) do
            s = s .. '"' .. k .. '": ' .. table2Json(v) .. ', '
         end
         s = string.sub(s, 1, -3) .. ' }'
      end
      return s
   else
      return '"' .. string.gsub(tostring(o), "%c", "") .. '"'
   end
end

-- dumpFile: dump a file to stdout
function dumpFile(filename)
   local inf = io.open(filename, 'r')
   if (inf == nil) then
      pmMessage("Cannot open file " .. filename, 2)
      return false
   end
   local when = os.date('%x %X')
   local str = string.format("Status of file %s at %s\n", filename, when) .. "\n" .. inf:read("*all")
   inf:close()
   return str
end

-- pmValidatePIN
function pmValidatePIN(PINCode)
   debug("pmValidatePIN: " .. (PINCode or "none"))
   if (PINCode ~= nil and string.len(PINCode) == 4) then
      --local pinPDU = string.char(tonumber(string.sub(PINCode, 1, 2), 16), tonumber(string.sub(PINCode, 3, 4), 16))
      local check = pmEncryptPIN(PINCode)
      if (check == pmSettings_t.masterCode) then
         local success = updateIfNeeded(PANEL_SID, "EnableProgram", check, pmPanelDev) 
         return '{ "valid": true, "value": ' .. check .. ', "updated": ' .. (success and 'true' or 'false') .. '}'
      end
   end
   return '{ "valid": false }'
end

-- pmCallbackHandler(lul_request, lul_parameters, lul_outputformat)
function pmCallbackHandler(lul_request, lul_parameters, lul_outputformat)
   debug("pmCallbackHandler: request " .. lul_request)
   -- Forwarder makes output format empty.
   if (lul_outputformat ~= "xml") then
      if (lul_request == "GetEventLog" .. pmPanelDev) then
         return table2Json(pmEventLog_t)
      elseif (lul_request == "GetPanelConfig" .. pmPanelDev) then
         return table2Json(pmSettings_t)
      elseif (lul_request == "GetBackupFiles" .. pmPanelDev) then
         return table2Json(pmGetBackupFiles())
      elseif (lul_request == "GetPduLogFile" .. pmPanelDev) then
         return dumpFile(pmLogFilename)
      elseif (lul_request == "GetSettingsFile" .. pmPanelDev) then
         return dumpFile(pmSettingsFilename)
      elseif (lul_request == "GetCrashFile" .. pmPanelDev) then
         return dumpFile(pmCrashFilename)
      elseif (lul_request == "GetLuaLogFile") then
         return dumpFile("/etc/log/cmh/LuaUPnP.log")
      elseif (lul_request == "ValidatePIN" .. pmPanelDev) then
         return pmValidatePIN(lul_parameters.PINCode)
      end
   end
end
