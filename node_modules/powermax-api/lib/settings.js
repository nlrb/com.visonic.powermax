"use strict";

var pm  = require('./tables.js');

var locale = Homey.manager('i18n').getLanguage();

function isZero(element) {
	return element === 0;
}

function settings(state) {
	this.rawSettings = [];
	this.state = state;
	this.debug = state.debug;
	// Panel information
	this.config = {}; // Panel configuration
	this.zones = {}; // Zone information
	this.x10 = {}; // x10 devices
}

// pmDecodeConfig
settings.prototype.decodeConfig = function(addr, item, descr) {
	var val = '';
	var page = Math.floor(addr / 0x100);
	var pos = addr % 0x100;
	if (item.type == "BYTE") {
		var mask = (1 << item.psize) - 1;
		var offset = item.pbitoff || 0;
		val = (this.rawSettings[page][pos] >> offset) & mask;
	} else if (item.type == "PHONE") {
		for (var j = 0; j < item.psize / 8; j++) {
			var nr = this.rawSettings[page][pos + j];
			if (nr != 0xFF) {
				val += ('0' + nr.toString(16).toUpperCase()).slice(-2);
			}
		}
	} else if (item.type == "TIME") {
		val = this.rawSettings[page][pos].toString() +  ':' + ('0' + this.rawSettings[page][pos + 1].toString()).slice(-2);
	} else if  (item.type == "CODE" || item.type == "ACCOUNT") {
		for (var j = 0; j < item.psize / 8; j++) {
			var nr = this.rawSettings[page][pos + j];
			val += ('0' + nr.toString(16)).slice(-2);
		}
		if (item.type == "CODE" && item.size == 16) {
			//val = pmEncryptPIN(val);
			//val = [ this.rawSettings[page][pos], this.rawSettings[page][pos + 1] ];
		}
	} else if (item.type == "STRING") {
		for (var j = 0; j < item.psize / 8; j++) {
			var nr = this.rawSettings[page][pos + j];
			if (nr != 0xFF) {
				val += String.fromCharCode(nr);
			}
		}
	}
	if (item.type == "BYTE") {
		this.debug(descr + ": " + (item.posvalues[val] || "UNKNOWN") + " (" + val + ")");
	} else {
		this.debug(descr + ": " + val);
	}
	return val;
}

// pmWriteSettings: add a certain setting to the settings table
settings.prototype.write = function(page, index, setting) {
	var len = setting.length;
	var wrap = (index + len - 0x100);
	var sett = [];
	if (wrap > 0) {
		sett[0] = setting.slice(0, len - wrap);
		sett[1] = setting.slice(len - wrap, len);
		wrap = 1;
	} else {
		sett[0] = setting;
		wrap = 0;
	}
	for (var i = 0; i <= wrap; i++) {
		var p = page + i;
		if (this.rawSettings[p] == null) {
			this.rawSettings[p] = Array(0x100).fill(0xFF);
		}
		len = sett[i].length;
		if (i == 1) {
			index = 0;
		}
		this.rawSettings[p] = this.rawSettings[p].slice(0, index).concat(sett[i], this.rawSettings[p].slice(index + len, 0xFF));
	}
}

// pmReadSettings
settings.prototype.read = function(item) {
	var index = item[0];
	var page = item[1];
	var len = item[2] + 0x100 * item[3];
	var s = [];
	if (this.rawSettings[page] != null) {
		while (len > 0) {
			var str = this.rawSettings[page].slice(index, index + len);
			s = s.concat(str);
			page++;
			index = 0;
			len -= str.length;
		}
	}
	return s;
}

settings.prototype.process = function(what) {
	var state = this.state;
	this.debug('Processing settings "' + what + '"...');

	var panelTypeNr = state.panelTypeNr - 1; // arrays start at 0
	var zoneCnt = pm.panelConfig.CFG_WIRELESS[panelTypeNr] + pm.panelConfig.CFG_WIRED[panelTypeNr];
	var customCnt = pm.panelConfig.CFG_ZONECUSTOM[panelTypeNr];
	var userCnt = pm.panelConfig.CFG_USERCODES[panelTypeNr];
	var partitionCnt = pm.panelConfig.CFG_PARTITIONS[panelTypeNr];
	var sirenCnt = pm.panelConfig.CFG_SIRENS[panelTypeNr];
	var keypad1wCnt = pm.panelConfig.CFG_1WKEYPADS[panelTypeNr];
	var keypad2wCnt = pm.panelConfig.CFG_2WKEYPADS[panelTypeNr];

	if (what == 'all' || what == 'MSG_DL_PANELFW') {
		// Process software information
		var item = this.read(pm.download.MSG_DL_PANELFW);
		if (item.length != 0) {
			var panelEprom = String.fromCharCode.apply(String, item.slice(0, 0x10));
			var panelSoftware = String.fromCharCode.apply(String, item.slice(0x10, 0x20));
			this.debug('EPROM: ' + panelEprom + '; SW: ' + panelSoftware);
			this.config.panelEprom = panelEprom;
			this.config.panelSoftware = panelSoftware;
		}
	}
	if (what == 'all' || what == 'MSG_DL_SERIAL') {
		var panelserialType = this.read(pm.download.MSG_DL_SERIAL);
		if (panelserialType.length != 0) {
			//pmEncryptionKey = string.sub(panelserialType, 1, 4)
			/* panelTypeNr and panelType are already set in handler 'handleInfo'
			panelTypeNr = panelserialType[7] + 1;
			state.panelTypeNr = panelTypeNr; // TODO: do we need this?
			var type = pm.panelType[panelTypeNr] || "UNKNOWN";
			this.config.panelType = type;
			this.debug('panelTypeNr: ' + panelTypeNr + '; type: ' + type);
			*/
			// Process panel type and serial
			var idx = ('0' + panelserialType[7].toString(16)).slice(-2) + ('0' + panelserialType[6].toString(16)).slice(-2);
			var panelModel = pm.panelModel[idx] || "UNKNOWN";
			this.config.panelModel = panelModel;
			var panelserial = '';
			for (var i = 0; i < 5; i++) {
				var nr = panelserialType[i];
				var s = (nr == 0xFF) ? "." : ('0' + nr.toString(16)).slice(-2);
				panelserial += s;
			}
			this.debug('Panel ' + panelModel + ' with serial ' + panelserial);
			this.config.panelSerial = panelserial;
		  //pmDumpSettings()
		}
	}
	if (what == 'all' && state.powerlinkMode == true) {
		// Check if time sync was OK
		if (state.syncTimeCheck != null) {
			var item = this.read(pm.download.MSG_DL_TIME);
			if (item.length != 0) {
				var timeRead = new Date(item[5] + 2000, item[4] - 1, item[3], item[2], item[1], item[0], 0);
				var timeSet = state.syncTimeCheck;
				if (timeRead.valueOf() >= timeSet.valueOf() && timeRead.valueOf() <= timeSet.valueOf() + 1000) {
					this.debug("Time sync OK (" + timeRead.toString() + ")");
				} else {
					this.debug("Time sync FAILED (got " + timeRead.toString() + "; expected " + timeSet.toString() + ')');
				}
			}
		}
		this.debug("Processing settings information")

		// Process all configuration settings
		for (var name in pm.panelSettings) {
			var item = pm.panelSettings[name];
			var addr = item.poff;
			if (item.count != null) {
				var tab = [];
				var label = item.name;
				for (var c = 0; c < item.count; c++) {
					var full = label[c];
					if (full == null) {
						full = label.replace("<x>", c);
					}
					tab[c] = { name: full, val: this.decodeConfig(addr, item, name) };
					addr = addr + item.pstep;
				}
				this.config[name] = tab;
			} else {
				this.config[name] = { name: item.name, val: this.decodeConfig(addr, item, item.name) };
			}
		}

		// Make sure zone names are not all capitals for display
		var zoneNameList = [];
		if (this.config.zoneNameRaw.length != 0) {
			var list = this.config.zoneNameRaw;
			for (var i = 0; i < list.length; i++) {
				zoneNameList[i] = list[i].val[0] + list[i].val.slice(1).trim().toLowerCase();
			}
		}

/*
	  // Process communication settings
	  pmBellTime = pmSettings_t.bellTime or 1
	  pmSilentPanic = (pmSettings_t.panicAlarm == 1) or false
	  pmQuickArm = (pmSettings_t.quickArm == 1) or false
	  pmBypassOff = (pmSettings_t.bypass == 0) or true
	  if (pmSensorArm == "auto") {
		 pmSensorShowBypass = not(pmBypassOff)
	  } else {if (pmSensorArm == "bypass") {
		 pmSensorShowBypass = true
	  } else {if (pmSensorArm == "live") {
		 pmSensorShowBypass = false
	  }
	  for i = 1, 4; i++) {
		 if (pmSettings_t.ringbackNrs[i] != "") {
			pmPhoneNr_t[i] = pmSettings_t.ringbackNrs[i]
		 }
	  }

*/
		// Process user pin codes
		var item;
		if (this.state.powerMaster == false) { // PowerMax models
			item = this.read(pm.download.MSG_DL_PINCODES);
		} else { // PowerMaster models
			item = this.read(pm.download.MSG_DL_MR_PINCODES);
		}
		if (item.length != 0) {
			this.config.userCode = [];
			for (var i = 0; i < userCnt; i++) {
				var pin = item.slice(2 * i, 2 * i + 2);
				if (!pin.every(isZero)) {
					this.config.userCode[i] = pin;
				}
			}
		}

		// Store partition info & check if partitions are on
		var partition = this.read(pm.download.MSG_DL_PARTITIONS);
		if (partition.length == 0 || partition[1] == 0) {
			partitionCnt = 1;
		}

		// Process zone settings
		var zoneNames, itemMr;
		if (this.state.powerMaster == false) { // PowerMax models
			zoneNames = this.read(pm.download.MSG_DL_ZONENAMES);
		} else { // PowerMaster models
			zoneNames = this.read(pm.download.MSG_DL_MR_ZONENAMES);
			itemMr = this.read(pm.download.MSG_DL_MR_ZONES);
		}
		var item = this.read(pm.download.MSG_DL_ZONES);
		if (item.length != 0 && zoneNames.length != 0) {
			for (var i = 0; i < zoneCnt; i++) {
				var zoneName = zoneNameList[zoneNames[i]];
				var zoneEnrolled;
				if (this.state.powerMaster == false) {  // PowerMax models
					zoneEnrolled = !item.slice(i * 4, i * 4 + 3).every(isZero);
				} else { // PowerMaster models (check only 5 of 10 bytes)
					zoneEnrolled = !itemMr.slice(i * 10 + 4, i * 10 + 9).every(isZero);
				}
				if (zoneEnrolled == true) {
					var zoneInfo, sensorId, sensorType, sensorName;
					if (this.state.powerMaster == false) {  // PowerMax models
						zoneInfo = item[i * 4 + 3];
						sensorId = item[i * 4 + 2];
						let id = '0x' + (sensorId & 0xF).toString(16)
						sensorType = pm.zoneSensor[id] || "UNKNOWN (" + id + ")";
					} else { // PowerMaster models
						zoneInfo = item[i];
						sensorId = itemMr[i * 10 + 5];
						let id = '0x' + sensorId.toString(16)
						if (pm.zoneSensorMaster[id] !== undefined) {
							sensorType = pm.zoneSensorMaster[id].func
							sensorName = pm.zoneSensorMaster[id].name
						} else {
							sensorType = "UNKNOWN (" + id + ")"
						}
					}
					var zoneType = zoneInfo & 0x0F;
					var zoneChime = (zoneInfo >> 4) & 0x03;
					var part = [];
					if (partitionCnt > 1) {
						for (var j = 0; j < partitionCnt; j++) {
							if ((partition[0x11 + i] & Math.pow(2, j)) > 0) {
								part.push(j + 1);
							}
						}
					} else {
						part = [ 1 ];
					}
					this.debug('Zone ' + (i + 1) + ' (' + zoneName + '): ' + pm.zoneType[locale][zoneType] + ' (chime = '
						+ pm.zoneChime[locale][zoneChime] + ' ; sensor type = ' + sensorId.toString(16) + ' [' + sensorType + '])');
					this.zones[i + 1] = {
						stype: sensorType,
						sid: sensorId,
						sname: sensorName, // undefined if not known
						ztype: zoneType,
						ztypeName: pm.zoneType[locale][zoneType],
						zname: zoneName,
						zchime: pm.zoneChime[locale][zoneChime],
						partition: part
					}
				} else {
					delete this.zones[i + 1]; // remove zone if needed
				}
			}
		}

		// Process PGM/X10 settings
		var item = this.read(pm.download.MSG_DL_PGMX10);
		var x10Names = this.read(pm.download.MSG_DL_X10NAMES);
		if (item.length != 0 && x10Names.length != 0) {
			for (var i = 0; i <= 15; i++) {
				var enabled = false;
				var x10Name = 0x1f; // not installed
				for (var j = 0; j < 8; j++) {
					enabled |= item[5 + i + j * 0x10] != 0;
				}
				if (i > 0) {
					x10Name = x10Names[i - 1];
				}
				this.x10[i] = {
					nr: i,
					enabled: enabled || x10Name != 0x1f,
					name: (i == 0 ? 'PGM' : 'X10-' + i),
					type: (i == 0 ? 'onoff' : 'dim'),
					loc: (i == 0 || x10Name == 0x1f ? null : zoneNameList[x10Name])
				}
			}
		}
/*
	  if (pmPowerMaster == false) {
		 // Process keypad settings
		 setting = pmReadSettings(pmDownloadItem_t.MSG_DL_1WKEYPAD)
		 for i = 1, keypad1wCnt; i++) {
			var keypadEnrolled = (string.sub(setting, i * 4 - 3, i * 4 - 2) != string.char(0, 0))
			if (keypadEnrolled == true) {
			   deviceStr = string.format("%s,K1%d", deviceStr, i)
			}
		 }
		 setting = pmReadSettings(pmDownloadItem_t.MSG_DL_2WKEYPAD)
		 for i = 1, keypad2wCnt; i++) {
			var keypadEnrolled = (string.sub(setting, i * 4 - 3, i * 4 - 1) != string.char(0, 0, 0))
			if (keypadEnrolled == true) {
			   deviceStr = string.format("%s,K2%d", deviceStr, i)
			}
		 }
		 // Process siren settings
		 setting = pmReadSettings(pmDownloadItem_t.MSG_DL_SIRENS)
		 for i = 1, sirenCnt; i++) {
			var sirenEnrolled = (string.sub(setting, i * 4 - 3, i * 4 - 1) != string.char(0, 0, 0))
			if (sirenEnrolled == true) {
			   deviceStr = string.format("%s,S%02d", deviceStr, i)
			}
		 }
	  } else { // PowerMaster
		 // Process keypad settings
		 setting = pmReadSettings(pmDownloadItem_t.MSG_DL_MR_KEYPADS)
		 for i = 1, keypad2wCnt; i++) {
			var keypadEnrolled = (string.sub(setting, i * 10 - 5, i * 10 - 1) != string.char(0, 0, 0, 0, 0))
			if (keypadEnrolled == true) {
			   deviceStr = string.format("%s,K2%d", deviceStr, i)
			}
		 }
		 // Process siren settings
		 setting = pmReadSettings(pmDownloadItem_t.MSG_DL_MR_SIRENS)
		 for i = 1, sirenCnt; i++) {
			var sirenEnrolled = (string.sub(setting, i * 10 - 5, i * 10 - 1) != string.char(0, 0, 0, 0, 0))
			if (sirenEnrolled == true) {
			   deviceStr = string.format("%s,S%02d", deviceStr, i)
			}
		 }
	  }
*/
		state.sendMessage("MSG_RESTORE"); // also gives status
		this.state.starting = false;
		this.state.events.emit('busy', false)
	} else if (what == 'all') {
		state.sendMessage("MSG_STATUS");
		state.sendMessage("MSG_ZONENAME");
		state.sendMessage("MSG_ZONETYPE");
		this.state.starting = false;
		this.state.events.emit('busy', false)
	}
	//pmUserMessage("READY_USE")
}

module.exports = settings;
