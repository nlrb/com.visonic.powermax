"use strict";

const pm  = require('./tables.js');

function isZero(element) {
	return element === 0;
}

class Settings {

	constructor(state) {
		this.rawSettings = [];
		this.state = state;
		this.debug = state.debug;
		// Panel information
		this.config = {}; // Panel configuration
		this.zones = {}; // Zone information
		this.x10 = {}; // x10 devices
	}

	// pmDecodeConfig
	decodeConfig(addr, item, descr) {
		let val = '';
		let page = Math.floor(addr / 0x100);
		let pos = addr % 0x100;
		if (item.type == "BYTE") {
			let mask = (1 << item.psize) - 1;
			let offset = item.pbitoff || 0;
			val = (this.rawSettings[page][pos] >> offset) & mask;
		} else if (item.type == "PHONE") {
			for (let j = 0; j < item.psize / 8; j++) {
				let nr = this.rawSettings[page][pos + j];
				if (nr != 0xFF) {
					val += ('0' + nr.toString(16).toUpperCase()).slice(-2);
				}
			}
		} else if (item.type == "TIME") {
			val = this.rawSettings[page][pos].toString() +  ':' + ('0' + this.rawSettings[page][pos + 1].toString()).slice(-2);
		} else if  (item.type == "CODE" || item.type == "ACCOUNT") {
			for (let j = 0; j < item.psize / 8; j++) {
				let nr = this.rawSettings[page][pos + j];
				val += ('0' + nr.toString(16)).slice(-2);
			}
			if (item.type == "CODE" && item.size == 16) {
				//val = pmEncryptPIN(val);
				//val = [ this.rawSettings[page][pos], this.rawSettings[page][pos + 1] ];
			}
		} else if (item.type == "STRING") {
			for (let j = 0; j < item.psize / 8; j++) {
				let nr = this.rawSettings[page][pos + j];
				if (nr != 0xFF) {
					val += String.fromCharCode(nr);
				}
			}
		}
		if (item.type == "BYTE") {
			this.debug(descr + ": " + (item.posvalues[val] || "UNKNOWN") + " (" + val + ")");
		} else {
			this.debug(descr + ": " + val);
		}
		return val;
	}

	// pmWriteSettings: add a certain setting to the settings table
	write(page, index, setting) {
		let len = setting.length;
		let wrap = (index + len - 0x100);
		let sett = [];
		if (wrap > 0) {
			sett[0] = setting.slice(0, len - wrap);
			sett[1] = setting.slice(len - wrap, len);
			wrap = 1;
		} else {
			sett[0] = setting;
			wrap = 0;
		}
		for (let i = 0; i <= wrap; i++) {
			let p = page + i;
			if (this.rawSettings[p] == null) {
				this.rawSettings[p] = Array(0x100).fill(0xFF);
			}
			len = sett[i].length;
			if (i == 1) {
				index = 0;
			}
			this.rawSettings[p] = this.rawSettings[p].slice(0, index).concat(sett[i], this.rawSettings[p].slice(index + len, 0xFF));
		}
	}

	// pmReadSettings
	read(item) {
		let index = item[0];
		let page = item[1];
		let len = item[2] + 0x100 * item[3];
		let s = [];
		if (this.rawSettings[page] != null) {
			while (len > 0) {
				let str = this.rawSettings[page].slice(index, index + len);
				s = s.concat(str);
				page++;
				index = 0;
				len -= str.length;
			}
		}
		return s;
	}

	process(what) {
		let state = this.state;
		this.debug('Processing settings "' + what + '"...');

		let panelTypeNr = state.panelTypeNr - 1; // arrays start at 0
		let zoneCnt = pm.panelConfig.CFG_WIRELESS[panelTypeNr] + pm.panelConfig.CFG_WIRED[panelTypeNr];
		let customCnt = pm.panelConfig.CFG_ZONECUSTOM[panelTypeNr];
		let userCnt = pm.panelConfig.CFG_USERCODES[panelTypeNr];
		let partitionCnt = pm.panelConfig.CFG_PARTITIONS[panelTypeNr];
		let sirenCnt = pm.panelConfig.CFG_SIRENS[panelTypeNr];
		let keypad1wCnt = pm.panelConfig.CFG_1WKEYPADS[panelTypeNr];
		let keypad2wCnt = pm.panelConfig.CFG_2WKEYPADS[panelTypeNr];

		if (what == 'all' || what == 'MSG_DL_PANELFW') {
			// Process software information
			let item = this.read(pm.download.MSG_DL_PANELFW);
			if (item.length != 0) {
				let panelEprom = String.fromCharCode.apply(String, item.slice(0, 0x10));
				let panelSoftware = String.fromCharCode.apply(String, item.slice(0x10, 0x20));
				this.debug('EPROM: ' + panelEprom + '; SW: ' + panelSoftware);
				this.config.panelEprom = panelEprom;
				this.config.panelSoftware = panelSoftware;
			}
		}
		if (what == 'all' || what == 'MSG_DL_SERIAL') {
			let panelserialType = this.read(pm.download.MSG_DL_SERIAL);
			if (panelserialType.length != 0) {
				//pmEncryptionKey = string.sub(panelserialType, 1, 4)
				/* panelTypeNr and panelType are already set in handler 'handleInfo'
				panelTypeNr = panelserialType[7] + 1;
				state.panelTypeNr = panelTypeNr; // TODO: do we need this?
				let type = pm.panelType[panelTypeNr] || "UNKNOWN";
				this.config.panelType = type;
				this.debug('panelTypeNr: ' + panelTypeNr + '; type: ' + type);
				*/
				// Process panel type and serial
				let idx = ('0' + panelserialType[7].toString(16)).slice(-2) + ('0' + panelserialType[6].toString(16)).slice(-2);
				let panelModel = pm.panelModel[idx] || "UNKNOWN";
				this.config.panelModel = panelModel;
				let panelserial = '';
				for (let i = 0; i < 5; i++) {
					let nr = panelserialType[i];
					let s = (nr == 0xFF) ? "." : ('0' + nr.toString(16)).slice(-2);
					panelserial += s;
				}
				this.debug('Panel ' + panelModel + ' with serial ' + panelserial);
				this.config.panelSerial = panelserial;
			  //pmDumpSettings()
			}
		}
		if (what == 'all' && state.powerlinkMode == true) {
			// Check if time sync was OK
			if (state.syncTimeCheck != null) {
				let item = this.read(pm.download.MSG_DL_TIME);
				if (item.length != 0) {
					let timeRead = new Date(item[5] + 2000, item[4] - 1, item[3], item[2], item[1], item[0], 0);
					let timeSet = state.syncTimeCheck;
					if (timeRead.valueOf() >= timeSet.valueOf() && timeRead.valueOf() <= timeSet.valueOf() + 1000) {
						this.debug("Time sync OK (" + timeRead.toString() + ")");
					} else {
						this.debug("Time sync FAILED (got " + timeRead.toString() + "; expected " + timeSet.toString() + ')');
					}
				}
			}
			this.debug("Processing settings information")

			// Process all configuration settings
			for (let name in pm.panelSettings) {
				let item = pm.panelSettings[name];
				let addr = item.poff;
				if (item.count != null) {
					let tab = [];
					let label = item.name;
					for (let c = 0; c < item.count; c++) {
						let full = label[c];
						if (full == null) {
							full = label.replace("<x>", c);
						}
						tab[c] = { name: full, val: this.decodeConfig(addr, item, name) };
						addr = addr + item.pstep;
					}
					this.config[name] = tab;
				} else {
					this.config[name] = { name: item.name, val: this.decodeConfig(addr, item, item.name) };
				}
			}

			// Make sure zone names are not all capitals for display
			let zoneNameList = [];
			if (this.config.zoneNameRaw.length != 0) {
				let list = this.config.zoneNameRaw;
				for (let i = 0; i < list.length; i++) {
					zoneNameList[i] = list[i].val[0] + list[i].val.slice(1).trim().toLowerCase();
				}
			}

	/*
		  // Process communication settings
		  pmBellTime = pmSettings_t.bellTime or 1
		  pmSilentPanic = (pmSettings_t.panicAlarm == 1) or false
		  pmQuickArm = (pmSettings_t.quickArm == 1) or false
		  pmBypassOff = (pmSettings_t.bypass == 0) or true
		  if (pmSensorArm == "auto") {
			 pmSensorShowBypass = not(pmBypassOff)
		  } else {if (pmSensorArm == "bypass") {
			 pmSensorShowBypass = true
		  } else {if (pmSensorArm == "live") {
			 pmSensorShowBypass = false
		  }
		  for i = 1, 4; i++) {
			 if (pmSettings_t.ringbackNrs[i] != "") {
				pmPhoneNr_t[i] = pmSettings_t.ringbackNrs[i]
			 }
		  }

	*/
			// Process user pin codes
			let item;
			if (this.state.powerMaster == false) { // PowerMax models
				item = this.read(pm.download.MSG_DL_PINCODES);
			} else { // PowerMaster models
				item = this.read(pm.download.MSG_DL_MR_PINCODES);
			}
			if (item.length != 0) {
				this.config.userCode = [];
				for (let i = 0; i < userCnt; i++) {
					let pin = item.slice(2 * i, 2 * i + 2);
					if (!pin.every(isZero)) {
						this.config.userCode[i] = pin;
					}
				}
			}

			// Store partition info & check if partitions are on
			let partition = this.read(pm.download.MSG_DL_PARTITIONS);
			if (partition.length == 0 || partition[1] == 0) {
				partitionCnt = 1;
			}

			// Process zone settings
			let zoneNames, itemMr;
			if (this.state.powerMaster == false) { // PowerMax models
				zoneNames = this.read(pm.download.MSG_DL_ZONENAMES);
			} else { // PowerMaster models
				zoneNames = this.read(pm.download.MSG_DL_MR_ZONENAMES);
				itemMr = this.read(pm.download.MSG_DL_MR_ZONES);
			}
			item = this.read(pm.download.MSG_DL_ZONES);
			if (item.length != 0 && zoneNames.length != 0) {
				for (let i = 0; i < zoneCnt; i++) {
					let zoneName = zoneNameList[zoneNames[i]];
					let zoneEnrolled;
					if (this.state.powerMaster == false) {  // PowerMax models
						zoneEnrolled = !item.slice(i * 4, i * 4 + 3).every(isZero);
					} else { // PowerMaster models (check only 5 of 10 bytes)
						zoneEnrolled = !itemMr.slice(i * 10 + 4, i * 10 + 9).every(isZero);
					}
					if (zoneEnrolled == true) {
						let zoneInfo, sensorId, sensorType, sensorName;
						if (this.state.powerMaster == false) {  // PowerMax models
							zoneInfo = item[i * 4 + 3];
							sensorId = item[i * 4 + 2];
							let id = '0x' + sensorId.toString(16)
							if (pm.zoneSensorDetail[id] !== undefined) {
								sensorType = pm.zoneSensorDetail[id].func
								sensorName = pm.zoneSensorDetail[id].name
							} else {
								// Try to guess, only look at lower nibble
								id = '0x' + (sensorId & 0xF).toString(16)
								sensorType = pm.zoneSensor[id] || "UNKNOWN (" + id + ")"
							}
						} else { // PowerMaster models
							zoneInfo = item[i];
							sensorId = itemMr[i * 10 + 5];
							let id = '0x' + sensorId.toString(16)
							if (pm.zoneSensorMaster[id] !== undefined) {
								sensorType = pm.zoneSensorMaster[id].func
								sensorName = pm.zoneSensorMaster[id].name
							} else {
								sensorType = "UNKNOWN (" + id + ")"
							}
						}
						let zoneType = zoneInfo & 0x0F;
						let zoneChime = (zoneInfo >> 4) & 0x03;
						let part = [];
						if (partitionCnt > 1) {
							for (let j = 0; j < partitionCnt; j++) {
								if ((partition[0x11 + i] & Math.pow(2, j)) > 0) {
									part.push(j + 1);
								}
							}
						} else {
							part = [ 1 ];
						}
						this.debug('Zone ' + (i + 1) + ' (' + zoneName + '): ' + pm.zoneType[state.locale][zoneType] + ' (chime = '
							+ pm.zoneChime[state.locale][zoneChime] + ' ; sensor type = ' + sensorId.toString(16) + ' [' + sensorType + ', ' + sensorName + '])');
						this.zones[i + 1] = {
							stype: sensorType,
							sid: sensorId,
							sname: sensorName, // undefined if not known
							ztype: zoneType,
							ztypeName: pm.zoneType[state.locale][zoneType],
							zname: zoneName,
							zchime: pm.zoneChime[state.locale][zoneChime],
							partition: part
						}
					} else {
						delete this.zones[i + 1]; // remove zone if needed
					}
				}
			}

			// Process PGM/X10 settings
			item = this.read(pm.download.MSG_DL_PGMX10);
			let x10Names = this.read(pm.download.MSG_DL_X10NAMES);
			if (item.length != 0 && x10Names.length != 0) {
				for (let i = 0; i <= 15; i++) {
					let enabled = false;
					let x10Name = 0x1f; // not installed
					for (let j = 0; j < 8; j++) {
						enabled |= item[5 + i + j * 0x10] != 0;
					}
					if (i > 0) {
						x10Name = x10Names[i - 1];
					}
					this.x10[i] = {
						nr: i,
						enabled: enabled || x10Name != 0x1f,
						name: (i == 0 ? 'PGM' : 'X10-' + i),
						type: (i == 0 ? 'onoff' : 'dim'),
						loc: (i == 0 || x10Name == 0x1f ? null : zoneNameList[x10Name])
					}
				}
			}
	/*
		  if (pmPowerMaster == false) {
			 // Process keypad settings
			 setting = pmReadSettings(pmDownloadItem_t.MSG_DL_1WKEYPAD)
			 for i = 1, keypad1wCnt; i++) {
				let keypadEnrolled = (string.sub(setting, i * 4 - 3, i * 4 - 2) != string.char(0, 0))
				if (keypadEnrolled == true) {
				   deviceStr = string.format("%s,K1%d", deviceStr, i)
				}
			 }
			 setting = pmReadSettings(pmDownloadItem_t.MSG_DL_2WKEYPAD)
			 for i = 1, keypad2wCnt; i++) {
				let keypadEnrolled = (string.sub(setting, i * 4 - 3, i * 4 - 1) != string.char(0, 0, 0))
				if (keypadEnrolled == true) {
				   deviceStr = string.format("%s,K2%d", deviceStr, i)
				}
			 }
			 // Process siren settings
			 setting = pmReadSettings(pmDownloadItem_t.MSG_DL_SIRENS)
			 for i = 1, sirenCnt; i++) {
				let sirenEnrolled = (string.sub(setting, i * 4 - 3, i * 4 - 1) != string.char(0, 0, 0))
				if (sirenEnrolled == true) {
				   deviceStr = string.format("%s,S%02d", deviceStr, i)
				}
			 }
		  } else { // PowerMaster
			 // Process keypad settings
			 setting = pmReadSettings(pmDownloadItem_t.MSG_DL_MR_KEYPADS)
			 for i = 1, keypad2wCnt; i++) {
				let keypadEnrolled = (string.sub(setting, i * 10 - 5, i * 10 - 1) != string.char(0, 0, 0, 0, 0))
				if (keypadEnrolled == true) {
				   deviceStr = string.format("%s,K2%d", deviceStr, i)
				}
			 }
			 // Process siren settings
			 setting = pmReadSettings(pmDownloadItem_t.MSG_DL_MR_SIRENS)
			 for i = 1, sirenCnt; i++) {
				let sirenEnrolled = (string.sub(setting, i * 10 - 5, i * 10 - 1) != string.char(0, 0, 0, 0, 0))
				if (sirenEnrolled == true) {
				   deviceStr = string.format("%s,S%02d", deviceStr, i)
				}
			 }
		  }
	*/
			state.sendMessage("MSG_RESTORE"); // also gives status
			this.state.starting = false;
			this.state.emit('busy', false)
		} else if (what == 'all') {
			state.sendMessage("MSG_STATUS");
			state.sendMessage("MSG_ZONENAME");
			state.sendMessage("MSG_ZONETYPE");
			this.state.starting = false;
			this.state.emit('busy', false)
		}
		//pmUserMessage("READY_USE")
	}
}

module.exports = Settings;
