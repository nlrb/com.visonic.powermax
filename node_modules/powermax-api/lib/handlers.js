"use strict";

const pm = require('./tables.js'),
	event = require('events');

// bytes2Dword: convert 4 bytes into an double-word integer
function bytes2Dword(arr) {
	return arr[0] + 0x100 * arr[1] + 0x10000 * arr[2] + 0x1000000 * arr[3];
}

class Handlers {

	constructor() {
		// Event handling
		this.events = new event.EventEmitter();
		this.eventLog = {};
		// Incoming message handling
		this.incomingPdu =[];
		this.incomingPduLen = 0; // expected length
		this.varLenMsg = false;
		this.lastPdu = [];
		this.expectedResponse = [];
		this.waitingForResponse = 0;
		this.rightResponse = 0;
		this.crcErrorCount = 0;
	}

	// Update a variable only if the value will change
	updateStatus(what, field, newVal) {
		if (this.zone === undefined || this.zone[what] === undefined) {
			this.zone[what] = {};
		}
		let curVal = this.zone[what][field];
		let changed = curVal != null && typeof newVal == 'object' ? newVal.nr != curVal.nr : newVal != curVal;
		if (changed) {
			this.zone[what][field] = newVal;
			this.events.emit(what, field, newVal);
			if (typeof newVal == 'object') {
				curVal = JSON.stringify(curVal);
				newVal = JSON.stringify(newVal);
			}
			this.debug(what + ':' + field + ' was ' + curVal + ' now ' + newVal);
			return true;
		} else {
			return false;
		}
	}

	// pmHandleAck (0x02)
	handleAck() {
		if (this.lastSentPdu != null) {
			let lastSentPduType = this.lastSentPdu[1];

			if (lastSentPduType == 0x0F && this.starting && this.readAllSettings) {
				this.powerlinkMode = true; // we have all info
				this.settings.process('all');
				this.events.emit('download', 'done');
			}
			return true;
		}
		return false;
	}

	// pmHandleTimeout (0x06)
	handleTimeout() {
	   this.debug("Powermax sends timeout");
	   this.expectedResponse = [0x06];
	   this.sendMessage("MSG_EXIT");
	   return true
	}

	// pmHandleDenied (0x08)
	handleDenied() {
		let lastSentPduType = this.lastSentPdu[1];
   	this.debug("Handling DENIED message (" + lastSentPduType + ")");

   	if ((lastSentPduType & 0xA0) == 0xA0) { // A0, A1, AA
		  //pmUserMessage("WRONG_PIN")
		  if (lastSentPduType == 0xA0) {
				this.eventLog = { done: true, denied: true, items: [], time: new Date() };
				this.events.emit('eventLog');
  			this.events.emit('busy', false);
		  }
   	} else if (lastSentPduType == 0x24) {
		  this.powerlinkMode = false;
		  this.starting = false;
		  this.events.emit('download', 'failed');
		  //pmUserMessage("NOT_ENROLLED");
		  //this.settings.process();
   	}
   	this.expectedResponse = [0x08];
		this.events.emit('busy', false)
   	return true
	}

	// pmHandleStop (0x0B)
	handleStop() {
	   // We're not expecting any more responses
	   this.readAllSettings = true;
	   this.expectedResponse = [];
	   return true
	}

	// pmHandleDownloadRetry (0x25)
	handleDownloadRetry() {
	   // Panel is not ready to enter download mode
	   let waitTime = this.incomingPdu[4] * 1000;
	   this.expectedResponse[0] = 0x25; // act like this was expected
	   this.sendTimer = setTimeout(() => { this.sendDelayed({ msg: 'RETRY', pdu: this.lastSentPdu, resp: 0x3C }); }, waitTime);
	}

	// pmHandleSettings (0x33)
	handleSettings() {
		if (this.lastSentPdu != null) {
			let index = this.incomingPdu[2];
			let page = this.incomingPdu[3];
			let lastSentPduType = this.lastSentPdu[1];
			this.debug('Received Powermax setting page ' + page + ' index ' + index);
			if (lastSentPduType == 0x0A) {
				this.expectedResponse.push(0x33); // we're not done; keep them coming
			}
			this.settings.write(page, index, this.incomingPdu.slice(4, 12));
			this.events.emit('download', 'received:' + page + ',' + index);
			return true;
		}
		return false;
	}

	// pmHandleInfo (0x3C)
	handleInfo() {
		let panelTypeNr = this.incomingPdu[7] + 1;
		let powerMaster = (panelTypeNr >= 8);
		if (this.forceModel !== 'auto') {
			powerMaster = this.forceModel === 'powermaster'
		}
		this.panelTypeNr = panelTypeNr;
		this.powerMaster = powerMaster;
		let type = pm.panelType[panelTypeNr] || "UNKNOWN";
		this.settings.config.panelType = type;
		this.debug("Model: " + type + "; Nr: " + panelTypeNr + "; Master: " + (powerMaster ? "Yes" : "No"));
		if (this.starting) {
			this.events.emit('download', 'start');
			this.powerlinkEnrolled();
		}
		return true
	}

	// pmHandleSettingsItem (0x3F)
	handleSettingsItem() {
		let idx = this.incomingPdu[2];
		let page = this.incomingPdu[3];
		let len = this.incomingPdu[4];
		this.debug('Received Powermax setting page ' + page + ' index ' + idx);
		this.settings.write(page, idx, this.incomingPdu.slice(5, 5 + len));
		for (let i in pm.download) {
			let item = pm.download[i];
			if (item[0] == idx && item[1] == page && item[2] == len && item[3] == 0) {
				this.settings.process(i);
				this.events.emit('download', 'process:' + i);
			}
		}
	}

	// pmHandleEventlog (0xA0)
	handleEventlog() {
		let eventNum = this.incomingPdu[3];
		if (eventNum == 0x01) {
			this.eventLog = { done: false, denied: false, items: [], time: new Date() };
			this.events.emit('busy', true);
			this.expectedResponse.push(0xA0);
		} else if (this.eventLog.items) {
			let secNum = this.incomingPdu[4];
			let minNum = this.incomingPdu[5];
			let horNum = this.incomingPdu[6];
			let dayNum = this.incomingPdu[7];
			let monNum = this.incomingPdu[8];
			let yerNum = 2000 + this.incomingPdu[9];
			let eventZone = this.incomingPdu[10];
			let logEvent = this.incomingPdu[11];
			let zoneStr = pm.logUser[this.locale][eventZone] || "UNKNOWN";
			//TODO:if (isPanelEvent == true) {
			//   pmEventLog = pmEventLog + "  * "
			//else
			//   pmEventLog = pmEventLog + "    "
			//end
			let eventStr = pm.logEvent[this.locale][logEvent] || "UNKNOWN";
			let idx = eventNum - 1;
			let event = {};
			let time = ('0' + horNum).slice(-2) + ':' + ('0' + minNum).slice(-2);
			if (pm.panelConfig.CFG_PARTITIONS[this.panelTypeNr] > 1) {
				let part = 0;
				for (let i = 1; i <= 3; i++) {
					part = (secNum % (2 * i) >= i) ? i : part;
				}
				event = { partition: (part == 0 ? "Panel" : part), time: time };
			} else {
				time += ':' + ('0' + secNum).slice(-2);
				event = { partition: (eventZone == 0 ? "Panel" : "1"), time: time };
			}
			event.date = ('0' + dayNum).slice(-2) + '/' + ('0' + monNum).slice(-2) + '/' + yerNum;
			event.zone = zoneStr;
			event.event = eventStr;
			this.debug(event, eventNum, this.incomingPdu[2]);
			this.eventLog.items.push(event);
			this.eventLog.done = eventNum == this.incomingPdu[2];
			this.events.emit('eventLog')
			if (this.eventLog.done) {
				this.events.emit('busy', false);
			}
		}
		return true;
	}

	// pmHandleStatus (0xA5)
	handleStatus() {
		let displaySensorBypass = (sensor) => {
			let armed
			/*
			if (this.sensorShowBypass == true) {
				armed = (sensor['bypass'] == true) ? 0 : 1;
			} else {
				let zoneType = sensor['ztype'] - 1;
				let mode = this.sysStatus & 0x0F;
				armed = ((zoneType > 0) && (sensor['bypass'] != true)
					&& ((zoneType & 0x14) == 0) || (mode == 0x5) || ((mode == 0x4) && (zoneType % 6 != 0)))) ? "1" : "0";
			}
			updateIfNeeded(SECURITY_SID, "Armed", armed, sensor['id']);
			*/
		}

		let msgTot = this.incomingPdu[2];
		let eventType = this.incomingPdu[3];
		//if (msgTot > 0 && eventType != msgTot) {
		//	  this.expectedResponse.push(0xA5);// we're not done; keep them coming
		//}
		if (eventType == 0x01) { // Zone alarm status
			this.debug("Received zone alarm status message")
			let alarmStatus = bytes2Dword(this.incomingPdu.slice(4, 8));
			let tamperStatus = bytes2Dword(this.incomingPdu.slice(8, 12));
			for (let i = 1; i <= 30; i++) {
				let alarm = (alarmStatus & Math.pow(2 , (i - 1))) > 0;
				let tamper = (tamperStatus & Math.pow(2, (i - 1))) > 0;
				if (this.settings.zones[i] != null) {
					if (this.updateStatus('zone.' + i, 'tripAlarm', alarm)) {
						this.debug('Updating trip alarm status for zone device ' + i + ' (' + alarm + ')');
						this.events.emit('zoneTripAlarm', { zone: i, state: alarm });
					}
					if (this.updateStatus('zone.' + i, 'tamperAlarm', tamper)) {
						this.debug('Updating tamper alarm status for zone device ' + i + ' (' + tamper + ')');
						this.events.emit('zoneTamperAlarm', { zone: i, state: tamper });
					}
				} else {
					if (alarm) {
						this.debug('Sensor zone ' + i + ' in trip alarm, but no device found!');
					} else if (tamper) {
						this.debug('Sensor zone ' + i + ' tamper alarm, but no device found!');
					}
				}
			}
		} else if (eventType == 0x02) { // Zone open status
			this.debug("Received zone open status message")
			let zoneStatus = bytes2Dword(this.incomingPdu.slice(4, 8));
			let batteryStatus = bytes2Dword(this.incomingPdu.slice(8, 12));
			for (let i = 1; i <= 30; i++) {
				let trip = (zoneStatus & Math.pow(2 , (i - 1))) > 0;
				let battery = (batteryStatus & Math.pow(2, (i - 1))) > 0;
				if (this.settings.zones[i] != null) {
					if (this.updateStatus('zone.' + i, 'trip', trip)) {
						this.debug('Updating tripped status for zone device ' + i + ' (' + trip + ')');
						this.events.emit('zoneTrip', { zone: i, state: trip });
					}
					if (this.updateStatus('zone.' + i, 'battery', battery)) {
						this.debug('Updating battery status for zone device ' + i + ' (' + battery + ')');
						this.events.emit('zoneBattery', { zone: i, state: battery });
					};
				} else {
					if (trip) {
						this.debug('Sensor zone ' + i + ' tripped, but no device found!');
					} else if (battery) {
						this.debug('Sensor zone ' + i + ' low battery, but no device found!');
					}
				}
			}
		} else if (eventType == 0x03) { // Zone tamper message
			let inactiveStatus = bytes2Dword(this.incomingPdu.slice(4, 8));
			let tamperStatus = bytes2Dword(this.incomingPdu.slice(8, 12));
			for (let i = 1; i <= 30; i++) {
				let tamper = (tamperStatus & Math.pow(2, (i - 1))) > 0 ? true : false;
				if (this.settings.zones[i] != null) {
					if (this.updateStatus('zone.' + i, 'tamper', tamper)) {
						this.debug('Updating tamper status for zone device ' + i + ' (' + tamper + ')');
						this.events.emit('zoneTamper', { zone: i, state: tamper });
					}
				} else {
					if (tamper) {
						this.debug('Sensor zone ' + i + ' tampered, but no device found!');
					}
				}
			}
		} else if (eventType == 0x04) { // Zone event message
			let sysStatus = this.incomingPdu[4];
			this.sysStatus = sysStatus; // TODO: do we need this?
			let sysFlags  = this.incomingPdu[5];
			let eventZone = this.incomingPdu[6];
			let zoneEType = this.incomingPdu[7];

			if (zoneEType != 0x00) {
				this.debug("Event " + (pm.eventType[this.locale][zoneEType] || "UNKNOWN") + " in Zone " + eventZone);
				let zone = this.settings.zones[eventZone];
				if (zone == null) {
					this.debug("Unable to locate zone "  + eventZone);
				} else {
					if (zoneEType == 0x03) { // Open event door/window sensor
						this.updateStatus('zone.' + eventZone, 'trip', true); // prevent updating twice; status msg comes before event msg
					} else if (zoneEType == 0x04) { // Close event door/window sensor
						this.updateStatus('zone.' + eventZone, 'trip', false);
					} else if (zoneEType == 0x05) { // Motion event
						this.updateStatus('zone.' + eventZone, 'trip', true);
						if (this.motionTimeout[eventZone] != null) {
							clearTimeout(this.motionTimeout[eventZone]);
						}
						this.motionTimeout[eventZone] = setTimeout(() => {
							this.updateStatus('zone.' + eventZone, 'trip', false);
						}, 1000 * this.devSettings.motionTime);
					}
				}
			}

			// Update status of PGM & X10 devices
			let s;
			let x10Stat1  = this.incomingPdu[10];
			let x10Stat2  = this.incomingPdu[11];
			let x10Status = x10Stat1 + (x10Stat2 * 0x100);
			for (let i = 0; i <= 15; i++) {
				s = (i == 0 ? 'x10.PGM' : 'x10.' + i);
				let status = (x10Status & Math.pow(2, i)) > 0;
				if (this.updateStatus(s, 'on', status) == true) {
					this.debug('Updating status of X10 device ' + s + ' (status = ' + status + ')');
				}
			}

			// System status flags
			let sysFlagsStr = " ";
			let ready = (sysFlags & 1) == 1;
			let memory = (sysFlags & 2) == 2;
			let trouble = (sysFlags & 4) == 4;
			let alarm = (sysFlags & 128) == 128;
			this.updateStatus('system', 'ready', ready);
			this.updateStatus('system', 'memory', memory);
			this.updateStatus('system', 'trouble', trouble);
			this.updateStatus('system', 'alarm', alarm);
			if (!ready) {
				sysFlagsStr += ",NRDY";
			}
			if (memory) {
				sysFlagsStr += ",MEM";
			}
			if (trouble) {
				sysFlagsStr += ",TRBL";
			}
			if (alarm) {
				sysFlagsStr += ",ALRM";
			}
			let armMode = pm.isArmed[sysStatus] != null;
			let statusText = pm.sysStatus[this.locale] == null ? pm.sysStatus.en[sysStatus] : pm.sysStatus[this.locale][sysStatus];
			this.updateStatus('system', 'status',
				{ armed: armMode, nr: sysStatus, detail: pm.detailedArmMode[sysStatus], txt: statusText }
			);
			//let armMode = (armModeNum == 1) ? "Armed" : "Disarmed";
			s = '';
			for (let i = 0; i <= 7; i++) {
				if (sysFlags & Math.pow(2, i) != 0) {
					if (i == 5) {
						if (eventZone == 0xFF) {
							s += (pm.eventType[this.locale][zoneEType] || "UNKNOWN") + " from Panel, ";
					   } else {
							s += pm.eventType[this.locale][zoneEType] + " in Zone " + eventZone + ", ";
					   }
					} else {
						s += (pm.sysStatusFlags[this.locale][i] || "UNKNOWN") + ", ";
					}
				}
			}
			s = (s == "") ? "Not ready" : s.slice(-2);
			this.debug("System state is " + (pm.sysStatus[this.locale][sysStatus] || "UNKNOWN") + ' ' + sysFlagsStr);
			//updateIfNeeded(PARTITION_SID, "VendorStatus", (pmSysStatus_t[locale][pmSysStatus + 1]  or "UNKNOWN") + sysFlagsStr, pmPartitionDev_t[1])
			//updateIfNeeded(PARTITION_SID, "VendorStatusCode", string.format("%02X%02X", pmSysStatus, sysFlags), pmPartitionDev_t[1])
			//updateIfNeeded(PARTITION_SID, "VendorStatusData", s, pmPartitionDev_t[1])
			//updateIfNeeded(PARTITION_SID, "DetailedArmMode", (pmDetailedArmMode_t[pmSysStatus + 1] or "UNKNOWN"), pmPartitionDev_t[1])
			/*
			if (this.sensorShowBypass == false) {
				for (let i = 1; i <= 30; i++) {
					//let sensor = pmSensorDev_t[i]
					//if (sensor != null) {
					//   displaySensorBypass(sensor);
					//}
				 }
			}
			*/
		} else if (eventType == 0x06) {
			this.debug("Received zone bypass message")
			let zoneEnrolled = bytes2Dword(this.incomingPdu.slice(4, 8));
			let zoneBypass = bytes2Dword(this.incomingPdu.slice(8, 12));
			for (let i = 1; i <= 30; i++) {
				let enrolled = (zoneEnrolled & Math.pow(2, (i - 1))) > 0;
				let bypass = (zoneBypass & Math.pow(2, (i - 1))) > 0;
				this.updateStatus('zone.' + i, 'bypass', bypass);
				/*
				let sensor = pmSensorDev_t[i];
				if (sensor != null) {
					sensor['enrolled'] = enrolled;
					sensor['bypass'] = bypass;
					displaySensorBypass(sensor);
				} else if (enrolled == true) {
					this.debug("Found zone " + i + " to be enrolled while not registered.");
					pmSensorDev_t[i] = {};
					pmSensorDev_t[i].enrolled = enrolled;
					pmSensorDev_t[i].bypass = bypass;
				}
				*/
			}
		}
		return true;
	}

	// pmHandleZoneName (0xA3)
	handleZoneName() {
		let rowCnt = this.incomingPdu[3];
		for (let i = 1; i <= 8; i++) {
			let idx = (rowCnt - 1) * 8 + i;
			//let sensor = pmSensorDev_t[idx];
			//if (sensor != null) {
				let zoneName = this.incomingPdu[3 + i];
				//sensor.zname = pmZoneName_t[zoneName + 1]
				//this.debug("Adding zone name " + sensor.zname + " for zone " + idx);
			//}
	   }
	   return true;
	}

	// pmHandleZoneType (0xA6)
	handleZoneType() {
		let rowCnt = this.incomingPdu[3];
		for (let i = 1; i <= 8; i++) {
			let idx = (rowCnt - 1) * 8 + i;
			//let sensor = pmSensorDev_t[idx];
			//if (sensor != null) {
				let zoneInfo = this.incomingPdu[3 + i] - 0x1E;
				let zoneType = (zoneInfo & 0x0F) + 1;
				//sensor.ztype = zoneType
				//sensor.ztypeName = pmZoneType_t[locale][zoneType]
				//this.debug("Adding zone type " + sensor.ztypeName + " for zone " + idx);
			//}
		}
		return true;
	}

	// pmHandlePanel (0xA7)
	handlePanel() {
		let msgCnt = this.incomingPdu[2];
		for (let i = 1; i<= msgCnt; i++) {
			let eventZone = this.incomingPdu[2 + 2 * i];
			let logEvent  = this.incomingPdu[3 + 2 * i];
			let eventType = logEvent & 0x7F;
			let s = (pm.logEvent[this.locale][eventType] || 'UNKNOWN') + ' / ' + (pm.logUser[this.locale][eventZone] || 'UNKNOWN');
			this.debug("System message: " + s);
			let eventIdx = '0x' + ('0' + eventType.toString(16)).slice(-2);
			let alarmStatus = pm.panelAlarmType[eventIdx];
			let troubleStatus = pm.panelTroubleType[eventIdx];
			this.updateStatus('system', 'event', {
				nr: eventIdx,
				type: pm.logEvent[this.locale][eventType], // type of event
				userType: eventZone,
				userText: pm.logUser[this.locale][eventZone],
				alarmType: alarmStatus,
				alarmText: pm.panelAlarmText[this.locale][alarmStatus],
				troubleType: troubleStatus,
				toubleText: pm.panelTroubleText[this.locale][troubleStatus]
			});
			this.updateStatus('system', 'alarmType', {
				nr: alarmStatus,
				loc: pm.panelAlarmText[this.locale][alarmStatus],
				txt: (alarmStatus !== undefined ? pm.logEvent[this.locale][eventType] : undefined)
			});
			this.updateStatus('system', 'troubleType', {
				nr: troubleStatus,
				loc: pm.panelTroubleText[this.locale][troubleStatus],
				txt: (troubleStatus !== undefined ? pm.logEvent[this.locale][eventType] : undefined)
			});
			//luup.variable_set(PANEL_SID, "PanelStatusCode", string.format("%02X", logEvent), pmPanelDev)
			//luup.variable_set(PANEL_SID, "PanelStatusData", s, pmPanelDev)
			//luup.variable_set(PANEL_SID, "PanelAlarmType", alarmStatus, pmPanelDev)
			//luup.variable_set(PANEL_SID, "PanelTroubleType", troubleStatus, pmPanelDev)
			//luup.variable_set(PARTITION_SID, "LastUser", pmLogUser_t[eventZone + 1], pmPartitionDev_t[1])
			// Update siren status
			/*
			let noSiren = ((eventType == 0x0B) || (eventType == 0x0C)) && (this.silentPanic == true);
			if (alarmStatus != 'None') && (eventType != 0x04) && (noSiren == false) {
				for (let i = 1; i <= #pmSirenDev_t; i++) {
					luup.variable_set(SIREN_SID, "Status", "1", pmSirenDev_t[i])
				}
				pmSirenActive = pmTimeFunction() + 60 * pmBellTime
			}
			if (eventType == 0x1B) and (pmSirenActive != null) { // Cancel Alarm
				pmSirenActive = null
				for (let i = 1; i <= #pmSirenDev_t; i++) {
					luup.variable_set(SIREN_SID, "Status", "0", pmSirenDev_t[i])
				}
			}
			*/
			if (eventType == 0x60) { // System reset
				this.startDownload();
			}
		}
		return true, true // A7 always unexpected
	}

	// pmHandlePowerlink (0xAB)
	handlePowerlink() {
		let subType = this.incomingPdu[2];
		if (subType == 0x03) { // keepalive message
			this.sendAck(0x02);
			if (this.powerlinkMode == false) {
				this.debug("Got alive message while not in Powerlink mode; starting download")
				this.startDownload();
			}
			return true, true; // ignore alive message for expected response (never expected)
	  } else if (subType == 0x05) { // phone message
			let action = this.incomingPdu[4];
			/*
			if (action == 1) {
				pmUserMessage("CALL_USER", this.userCalling, pmPhoneNr_t[this.userCalling])
				this.userCalling += 1;
				if (this.userCalling > #pmPhoneNr_t) {
					this.userCalling = 1
				}
			} else if (action == 2) {
				pmUserMessage("CALL_ACK", this.userCalling)
				this.userCalling = 1
			}
			*/
			this.sendAck(0x02);
	  } else if (subType == 0x0A && this.incomingPdu[4] == 0x01) {
			this.debug("Enrolling Powerlink")
			this.sendMessage("MSG_ENROLL", { code: pm.secret }, true);
			//this.expectedResponse = [0xAB, 0x02, 0xA5].concat(this.expectedResponse.slice(1));
			this.expectedResponse = [0xAB, 0x02].concat(this.expectedResponse.slice(1));
			// TODO: only start download if panelType > 4 (but how?!)
			this.startDownload();
	  } else {
			this.sendAck(0x02);
	  }
	  return true
	}

	// handlePowerMaster (0xB0)
	handlePowerMaster() {
		let msgSubTypes = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
		0x18, 0x19, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x24, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x38, 0x39, 0x3A ];
		let msgType = this.incomingPdu[2]; // 00, 01, 04: req; 03: reply, so expecting 0x03
		let subType = this.incomingPdu[3];
		let msgLen = this.incomingPdu[4];
		this.debug('Received PowerMaster message', msgType.toString(16) + '/' + subType.toString(16), '(len = ' + msgLen + ')');
		return true
	}
}

module.exports = Handlers
