"use strict";

const pm  = require('./tables.js'),
	  net = require('net'),
	  Handlers = require('./handlers.js'),
	  Settings = require('./settings.js');

const MSG_RETRIES = 3;
const PL_RETRIES = 3;
const MAX_CRC_ERROR = 5;
const MAX_IGNORE_DOWNLOAD = 5;
const MAX_RESPONSE_TIME = 10000; // 10 seconds
const TIMEOUT = 40000; // 40 seconds

var debugOn = false;

// Debug logging
function localDebug() {
	if (debugOn) {
		let now = new Date();
		let itemdebug = (x) => { return (typeof x === 'object' ? JSON.stringify(x) : x) + ' ' };
		let time = now.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1");
		let ms = ('00' + now.getMilliseconds()).slice(-3);
		let text = '';
		for (let i = 0; i < arguments.length; i++) {
			let x = arguments[i];
			if (Object.prototype.toString.call(arguments[i]) === '[object Arguments]') {
				for (let j = 0; j < x.length; j++) {
					text += itemdebug(x[j]);
				}
			} else {
				text += itemdebug(x);
			}
		}
		console.log(time + '.' + ms, text.slice(0, -1));
	}
}

function pduToString(pdu) {
  let PDUstr = '';
	for (let i = 0; i < pdu.length; i++) {
		PDUstr += ('0' + pdu[i].toString(16)).slice(-2) + ' ';
	}
  return PDUstr;
}

/*
   Events:
   - found: a PowerMax device has been found; param: found ('no', 'active', 'inactive')
   - zone: a zone sensor has changed state; param: id, field, newVal (id = zone nr,
		field = ['tripAlarm', 'tamperAlarm', 'trip', 'tamper', 'battery', 'bypass'])
   - x10: an x10 device has changed state; param: id, field, newVal (id = x10 nr, field = ['on'])
   - system: the panel system state has changed; param: id, field, newVal (id = 0,
		field = ['status', 'ready', 'memory', 'trouble', 'alarm', 'event'])
			status: { armed (boolean), nr (int), txt (string) }
			event:  { ... }
			others return boolean
   - alarm: the alarm state has changed; param: id, field, newVal ??
   - zoneBattery: a zone battery event has occurred; param: zone, state
   - zoneTripAlarm: a zone battery event has occurred; param: zone, state
	 - eventLog: the event log received so far (field done indicates completenes)
	 - download: download state ('start', 'recieved:<page>,<index>', 'process:<setting>', 'failed', 'done')
*/

class PowerMax extends Handlers {
	// settings
	//  ip: <string> ip address
	//  port: <number> port number
	//	syncTime: <boolean> synchronize time on panel automatically or not

	// Main constructor
	constructor(locale, settings, debug) {

		super();
		this.locale = locale || 'en';
		this.ip_port = settings.ip + ':' + settings.port;
		this.forceModel = settings.forceModel || 'auto';
		this.downloadCode = settings.download || pm.secret;
		this.devSettings = settings;
		this.debug = debug || function() { localDebug('[' + this.ip_port + ']', arguments); };
		this.client;
		this.found = 'no' //TODO (id == null ? 'no' : 'inactive');
		this.intervalTimer;
		this.reconnectTimer;
		// Outgoing message handling
		this.outgoingQueue = [];
		this.sendTimer = null;
		this.sendMsgRetries = 0;
		this.actionBusy = false;
		// Panel configuration
		this.panelTypeNr = 0;
		this.powerMaster = false;
		this.starting = false;
		this.downloadRetry = 0;
		this.powerlinkRetry = 0;
		this.powerlinkMode = false;
		// Panel settings
		this.settings = new Settings(this);
		this.readAllSettings = false;
		this.downloadState;
		// State of each zone
		this.zone = new Map();
		this.motionTimeout = [];

		this.setMaxListeners(0); // infinity
		this.eventLog = {};
	/*
	this.on('zone', function(id, field, value) {
		this.debug('Zone status changed for zone ' + id + '; ' + field + ' = ' + value);
	});
	this.on('system', function(id, field, value) {
		this.debug('System status changed for ' + field + ' = ' + value);
	});
	*/
		this.on('download', (state) => {
			this.downloadState = state; // can be 'start', 'failed' or 'done'
		});
		this.on('found', (state) => {
			if (state.found && this.intervalTimer === undefined) {
				// Set up regular check for every 20 seconds
				this.intervalTimer = setInterval(() => {
					let now = new Date();
					// Check Powerlink keep-alive
					if (this.powerlinkMode && !this.starting) {
						let delta = now - (this.waitingForResponse || 0);
						this.debug('Checking last alive message (delta =', delta + ')');
						if (delta > 40000) {
							// Let Powermax know we are alive (and reset Powerlink communication error)
							this.debug('Clear Powerlink communication error');
							this.sendMessage("MSG_RESTORE");
							this.powerlinkRetry++;
							if (this.powerlinkRetry == PL_RETRIES) {
								this.powerlinkMode = false;
								this.powerlinkRetry = 0;
							}
						}
					}
					// Check message sending timeout
					let timeout = (now - this.waitingForResponse > TIMEOUT);
					let notRight = (now - this.rightResponse > MAX_RESPONSE_TIME);
					if (this.expectedResponse != '' && (timeout || notRight)) {
						// resend last message
						this.debug('*** Re-sending PDU (no or incorrect response) ***');
						if (this.sendMsgRetries == MSG_RETRIES) {
							this.handleCommException('no response');
						} else {
							this.sendMsgRetries++;
							this.expectedResponse = this.expectedResponse.slice(1);
							this.sendMessage(-1);
						}
					}
				}, 20000);
			}
		});

		this.openConnection(settings.ip, settings.port);
	}

	// Open the connection to this PowerMax panel
	openConnection(ip, port) {
		// Set up network communication
		this.client = new net.Socket();
		this.client.setTimeout(60000); // expect traffic once a minute
		// Register main response handler
		this.client.on('data', (data) => {
			//clearTimeout(waitTimer);
			this.processData(data);
		});
		// Error handler
		this.client.on('error', (err) => {
			this.debug(err);
			if (this.found != 'no') {
				//clearTimeout(waitTimer);
				this.closeConnection();
			}
		});
		// Timeout handler
		this.client.on('timeout', () => {
			this.debug('Connecion timed out.');
			this.emit('found', { found: this.found, err: 'Timed out' });
			this.closeConnection();
		});
		// Handle closed connections, try to re-open it
		this.client.on('close', () => {
			this.debug('Connecion closed (found =', this.found + ')');
			this.emit('found', { found: false, err: 'Connection closed' });
			if (this.found != 'no' && this.reconnectTimer === undefined) {
				// Connection dropped, try to re-connect every minute
				this.reconnectTimer = setInterval(() => {
					let ip = this.devSettings.ip;
					let port = this.devSettings.port;
					this.debug('Re-connecting to', ip + ':' + port);
					this.openConnection(ip, port);
				}, 60000);
			}
		});
		this.client.connect(port, ip, () => {
			this.debug('Connected to', this.ip_port);
			// Kill the re-try timer
			clearInterval(this.reconnectTimer);
			this.reconnectTimer = undefined;
			// Start communication
			this.startDownload();
		});
	}

	// Close the connection to this PowerMax panel
	closeConnection() {
		this.client.destroy();
		this.found = (this.found == 'no' ? 'no' : 'inactive');

		// Reset all variables
		this.incomingPdu =[];
		this.incomingPduLen = 0; // expected length
		this.varLenMsg = false;
		this.lastPdu = [];
		this.expectedResponse = [];
		this.waitingForResponse = 0;
		this.rightResponse = 0;
		this.crcErrorCount = 0;
		this.outgoingQueue = [];
		this.sendTimer = null;
		this.sendMsgRetries = 0;
		this.actionBusy = false;
		this.starting = false;
		this.downloadRetry = 0;
		this.powerlinkRetry = 0;
		this.powerlinkMode = false;
		this.readAllSettings = false;

		clearInterval(this.intervalTimer);
		this.intervalTimer = undefined;
	}

	handleCommException(reason) {
		this.debug('>>> Communication error:', reason, '- restarting <<<')
		let ip = this.devSettings.ip;
		let port = this.devSettings.port;
		this.closeConnection(); // start from scratch
		// Wait a second before we open the connection again. Other async processes need to finish.
		setTimeout(() => {
			this.debug('Re-connecting to', ip + ':' + port);
			this.openConnection(ip, port);
		}, 1000);
	}

	// Determine whether we are in normal operating mode or not
	isNormalMode() {
		let lastType = this.lastPdu[1];
		let normalMode = (lastType >= 0x80 || ((lastType < 0x10) && this.lastPdu[this.lastPdu.length - 2]) == 0x43);
		return normalMode;
	}

	// sendPdu: Send the pdu to the PowerMax via serial
	sendPdu (pdu) {
		let sendPdu = pm.calcCRC(pdu);
		let PDUstr = pduToString(sendPdu);
		this.debug('PDU sent to panel:', PDUstr);
		this.client.write(new Buffer(sendPdu));
		return sendPdu;
	}

	// sendAck: Send full or partial acknowledge to Powermax (depending on operating mode)
	sendAck(ackType) {
		if (this.isNormalMode() == true) {
			this.sendPdu([0x0D, ackType, 0x43, 0x00, 0x0A]);
		} else {
			this.sendPdu([0x0D, ackType, 0x00, 0x0A]);
		}
	}

	// startDownload
	startDownload() {
		if (this.starting == false) {
			this.emit('download', 'enroll');
			this.starting = true;
			this.emit('busy', true)
			this.sendMessage("MSG_DOWNLOAD", { code: this.downloadCode }); // If we get a NACK, then the download code is not valid (not enrolled)
		} else {
			this.downloadRetry++;
			if (this.downloadRetry > MAX_IGNORE_DOWNLOAD) {
				this.downloadRetry = 0;
				this.sendMessage("MSG_DOWNLOAD", { code: this.downloadCode }); // If we get a NACK, then the download code is not valid (not enrolled)
			} else {
				this.debug('Download not started as one is in progress.')
			}
		}
	}


	// writeMessage
	// item: address
	//   or: DL_xxx
	writeMessage(item, val) {
		let len = val.length;
		let addr;
		if (typeof item == 'string') {
			addr = pm.download[item].slice(0, 1);
		} else {
			addr = [item % 0x100, math.floor(item / 0x100)];
		}
		while (len > 0) {
			let s = val.slice(0, 0xAF);
			let l = (len > 0xB0) ? 0xB0 : len;
			this.debug('addr = ' + addr + ', len = ' + l);
			this.sendMessage("MSG_WRITE", { addr: addr, len: l, val: s });
			let page = string.byte(addr, 2)
			let index = string.byte(addr)
			//pmWriteSettings(page, index, s) // also update internal table
			len -= 0xB0;
			val = val.slice(0xB0);
			let a = 0x100 * page + index + 0xB0;
			addr = [a % 0x100, math.floor(a / 0x100)];
	    }
	}

	// sendDelayed
	sendDelayed(msgPdu) {
		this.debug('*** Trigger: delayed sending of', msgPdu.msg, ' ***');
		this.sendTimer = null;
		this.sendMessage('PDU', msgPdu);
	}

	// sendMessage: Send (known) messages to the PowerMax
	// Returns success: true: sent or queued; false: nothing sent
	sendMessage(msg, modifiers, immediate) {
		let outPdu = [];
		let response;
		let interval = new Date() - this.waitingForResponse;
		let timeout = (interval > TIMEOUT);

		if (msg == -1) { // re-send last message
			msg = 'RESENDING';
			outPdu = this.lastSentPdu;
			response = this.expectedResponse;
			timeout = true;
		} else if (msg == 'PDU') {
			msg = modifiers.msg;
			outPdu = modifiers.pdu;
			response = modifiers.resp;
		} else if (msg != null) {
			let msgItem = pm.send[msg];
			outPdu = [0x0D];

			for (let i = 0; i < msgItem.msg.length; i++) {
				let elem = msgItem.msg[i];
				if (typeof elem != 'string') {
					outPdu.push(elem);
				} else {
					// handle modifier
					let p = elem.indexOf(':');
					let len = 1;
					if (p > 0) {
						len = Number(elem.slice(p + 1));
						elem = elem.slice(0, p);
					}
					let val = modifiers[elem];
					if (typeof val == 'number') {
						// make sure we have an array of correct length
						let tmp = val;
						val = [];
						for (let j = 0; j < len; j++) {
							val[j] = tmp & 0xff;
							tmp >>= 8;
						}
					} else {
						if (val == null || val.length != len) {
							this.debug('Provide array of length', len, 'for', elem);
							return false;
						}
					}
					outPdu = outPdu.concat(val);
				}
			}
			outPdu.push(0x00, 0x0A);
			response = msgItem.resp != null ? [ msgItem.resp ] : null;

			if (outPdu[1] == 0x3E) {
				let cnt = outPdu[4] + 0x100 * outPdu[5];
				//TODO: optimize
				for (let i = 0; i < Math.floor(cnt / 0xB0); i++) {
					response.push(msgItem.resp);
				}
			}
		}

		if (immediate == true || this.sendTimer == null && (timeout == true || this.expectedResponse.length == 0)) { // we are ready to send
			if (msg == null) { // get message from queue
				let tab = this.outgoingQueue.shift();
				if (tab == null) {
					// nothing to send
					return false
				}
				msg = tab.msg;
				outPdu = tab.pdu;
				response = tab.resp;
			}
			// check if the last read is at least 500 ms ago
			if (!immediate && interval < 500) {
				// there should be at least 500 ms between last receive and a new send
				this.debug('*** Send message,', msg, 'delayed ***')
				this.sendTimer = setTimeout(() => { this.sendDelayed({ msg: msg, pdu: outPdu, resp: response }); }, 500 - interval);
				return true;
			}
			// always expect an ACK (ACK send messages don't pass through here)
			this.expectedResponse = [0x02];
			if (response != null) {
				this.rightResponse =  new Date();
				this.expectedResponse = [0x02].concat(response);
			}
			this.lastPdu = this.sendPdu(outPdu);
			this.lastSentPdu = this.lastPdu;
			// TODO: check how to return false if sending failed
			this.waitingForResponse = new Date();
		} else if (msg != null) { // queue message
			this.outgoingQueue.push({ msg: msg, pdu: outPdu, resp: response });
		}
		return true;
	}

	// Process incoming PDUs
	processData(data) {
		// Don't assume we get a full PDU right away
		for (let p = 0; p < data.length; p++) {
			let pdu = data[p];
			let pduLen = this.incomingPdu.length;
			let success, ignore;

			if (pduLen == 4 && this.varLenMsg == true) {
				// Determine length of variable size message
				let msgType = '0x' + ('0'+ this.incomingPdu[1].toString(16).toUpperCase()).slice(-2);
				this.incomingPduLen += pdu + 7
				this.debug('Message', msgType + '; incomingPduLen =', this.incomingPduLen);
			}

		   if (pduLen == 0) {
				if (pdu == 0x0D) { // preamble
					let response = '';
					if (this.expectedResponse.length != 0) {
						response = pduToString(this.expectedResponse);
						if (response != '') {
							response = "; Expecting " + response;
						}
					}
					this.debug('Start of new PDU detected', response);
					this.incomingPdu[0] = pdu;
				}
			} else if (pduLen == 1) {
				let msgType = '0x' + ('0'+ pdu.toString(16).toUpperCase()).slice(-2);
				let msgType_t = pm.receive[msgType];
				this.incomingPduLen = msgType_t == null ? 0 : msgType_t.len || 0; // fix #2
				this.varLenMsg = (msgType > 0x10) && (msgType_t != null) && (msgType_t.len == null);
				if (!this.varLenMsg) {
					this.debug('Message', msgType + '; incomingPduLen =', this.incomingPduLen);
				}
				this.incomingPdu.push(pdu);
			} else if ((this.incomingPduLen == 0 && pdu == 0x0A) || (pduLen + 1 == this.incomingPduLen)) { // postamble
				this.incomingPdu.push(pdu);
				let crc;
				let msgType = '0x' + ('0'+ this.incomingPdu[1].toString(16).toUpperCase()).slice(-2);
				if (pdu != 0x0A && this.incomingPdu[pduLen - 1] == 0x43) {
					this.incomingPduLen++; // for 0x43
				} else if (crc = pm.checkCRC(this.incomingPdu, this.powerMaster) == true) {
					if (this.found != 'active') {
						this.found = 'active';
						this.emit('found', { found: true });
					}
					this.lastPdu = this.incomingPdu;
					let PDUstr = pduToString(this.incomingPdu);
					let msgType_t = pm.receive[msgType];
					this.debug('PDU received', PDUstr);
					this.waitingForResponse = new Date();

					if (msgType_t == null) {
						this.debug('Unhandled message', msgType);
						this.sendAck(0x02);
					} else {
						// Send an ACK if needed
						if (msgType_t.ack) {
						   this.sendAck(0x02);
						}
						// Handle the message
						let success, ignore;
						let handler = eval('this.' + msgType_t.handler);
						if (typeof handler !== 'function') {
							this.debug('Unhandled message', msgType + '; handler:', msgType_t.handler);
						} else {
							success, ignore = handler.call(this);
						}
						// Check response
						if (this.expectedResponse.length != 0) {
							// We've sent something and are waiting for a response - this is it
							let firstExpected = this.expectedResponse[0];
							let firstExpectedResponse = '0x' + ('0' + firstExpected.toString(16).toUpperCase()).slice(-2);
							this.expectedResponse = this.expectedResponse.slice(1);
							if (firstExpectedResponse != msgType) {
								if (ignore == true) { // ignore unexpected messages
									this.debug('Ignoring response...');
									this.expectedResponse.unshift(firstExpected);
								} else if (this.sendMsgRetries == 0) {
									this.debug('*** Waiting for next PDU (expected', firstExpectedResponse, 'got', msgType + ') ***');
									this.sendMsgRetries = 1; // don't respond immediately - first wait for the next response
									this.expectedResponse.unshift(firstExpected);
								} else {
									this.debug('*** Re-sending PDU (expected', firstExpectedResponse, 'got', msgType + ') ***');
									if (this.sendMsgRetries == MSG_RETRIES) {
										this.handleCommException('wrong response');
									} else {
										this.sendMsgRetries++;
										this.sendMessage(-1);
									}
								}
							} else {
								this.sendMsgRetries = 0;
								this.rightResponse = new Date();
							}
						}
					}
					this.incomingPdu = [];
					if (this.expectedResponse.length == 0) {
						this.sendMessage(null);
					}
				} else { // CRC check failed
					if (this.incomingPduLen > 0) {
						let PDUstr = pduToString(this.incomingPdu);
						this.debug('PDU with CRC error', PDUstr);
						this.sendAck(0x02);
						this.waitingForResponse = new Date();
						this.incomingPdu = [];
						if (msgType != 0xF1) { // ignore CRC errors on F1 message
							this.crcErrorCount++;
						}
						if (this.crcErrorCount > MAX_CRC_ERROR) {
							//this.handleCommException("CRC errors")
						}
					} else {
						this.debug('Length is now', pduLen, '(apparently PDU not complete)');
						let PDUstr = pduToString(this.incomingPdu);
						this.debug('Partial PDU', PDUstr);
					}
				}
			} else if (pduLen <= 0xC0) {
				this.incomingPdu.push(pdu);
			} else {
				let PDUstr = pduToString(this.incomingPdu);
				this.debug('Truncating PDU', PDUstr);
				this.incomingPdu = []; // messages should never be longer than 0xC0
			}
		} // end for
	};

	// Request a status events from the panel for a zone
	getZoneStatus(zone) {
		let id = 'zone.' + zone
		this.debug('getZoneStatus', id)
		if (this.zone !== undefined) {
			this.emit(id, 'trip', this.zone.get(id + ':trip'))
			this.emit(id, 'battery', this.zone.get(id + ':battery'))
			this.emit(id, 'tamper', this.zone.get(id + ':tamper'))
			this.emit(id, 'bypass', this.zone.get(id + ':bypass'))
			this.emit(id, 'tripAlarm', this.zone.get(id + ':tripAlarm'))
			this.emit(id, 'tamperAlarm', this.zone.get(id + ':tamperAlarm'))
		} else {
			// TODO: create specific message for a zone
			this.sendMessage("MSG_STATUS");
		}
	}

	// Bypass a list of zones
	// which: sensors to send the command for (array of numbers)
	setBypass(user, which, on) {
		if (which !== undefined && which.length > 0 && this.settings.config && this.settings.config.userCode) {
			let addr = 0;
			let pin = this.settings.config.userCode[user - 1];
			for (let i = 0; i < which.length; i++) {
				addr += Math.pow(2, which[i] - 1);
			}
			this.debug('setBypass', on, addr);
			// Update the status without knowing if it will succeed.
			// If it fails, it will be reset by the status message below.
			this.updateStatus('zone.' + which, 'bypass', on);
			if (on) {
				this.sendMessage("MSG_BYPASSEN", { pin: pin, bypass: addr });
			} else {
				this.sendMessage("MSG_BYPASSDI", { pin: pin, bypass: addr });
			}
			this.sendMessage("MSG_BYPASSTA"); // request status to check success and update variable
		}
	}

	// Check if another action is busy
	panelBusy() {
		return this.actionBusy || this.starting;
	}

	// Synchronize time from Homey to the PowerMax
	syncTime() {
		if (!this.panelBusy()) {
			this.actionBusy = true;
			this.emit('busy', true)
			this.sendMessage("MSG_DOWNLOAD", { code: this.downloadCode }); // Open download mode
			if (this.devSettings.syncTime) {
				let t = new Date();
				let year = t.getFullYear() - 2000;
				let timePdu = [t.getSeconds(), t.getMinutes(), t.getHours(), t.getDate(), t.getMonth() + 1, year];
				t.setMilliseconds(0);
				this.syncTimeCheck = t;
				this.sendMessage("MSG_SETTIME", { time: timePdu });
			}
			this.sendMessage("MSG_EXIT");  // Exit download mode
			this.actionBusy = false;
			this.emit('busy', false)
		} else {
			// busy, try again later
			setTimeout(() => { this.syncTime() }, 1000);
		}
	}

	// Control X10 devices
	// which: devices to send the command for (array of numbers; 0 = PGM)
	sendX10Command(which, what) {
		const x10cmds = { //TODO: move to tables
			'off': 0x0,
			'on': 0x01,
			'dim': 0x0a,
			'brighten': 0x0b
		}
		if (x10cmds[what] != null) {
			let addr = 0;
			for (let i = 0; i < which.length; i++) {
				addr += Math.pow(2, which[i]);
			}
			this.sendMessage("MSG_X10PGM", { cmd: x10cmds[what], device: addr });
		}
	}

	// Request the event log
	getEventLog(force) {
		let result = false;
		if (!force && this.eventLog.done) {
			this.emit('eventLog');
			result = true;
		} else if (!this.panelBusy()) {
			if (this.settings && this.settings.config && this.settings.config.userCode) {
				let pin = this.settings.config.userCode[0]; // always use user 1
				if (pin !== undefined) {
					this.sendMessage("MSG_EVENTLOG", { pin: pin });
					result = true;
				}
			}
		}
		return result;
	}

	// powerlinkEnrolled
	powerlinkEnrolled () {
		this.sendMessage("MSG_DL", { item: pm.download.MSG_DL_PANELFW }); // Request the panel FW
		this.sendMessage("MSG_DL", { item: pm.download.MSG_DL_SERIAL }); // Request serial & type (not always sent by default)
		this.sendMessage("MSG_DL", { item: pm.download.MSG_DL_ZONESTR }); // Read the names of the zones
		if (this.powerMaster) {
			this.sendMessage("MSG_DL", { item: pm.download.MSG_DL_MR_SIRKEYZON });
		}
		if (this.devSettings.syncTime) {
			let t = new Date();
			let year = t.getFullYear() - 2000;
			let timePdu = [t.getSeconds(), t.getMinutes(), t.getHours(), t.getDate(), t.getMonth() + 1, year];
			t.setMilliseconds(0);
			this.syncTimeCheck = t;
			this.sendMessage("MSG_SETTIME", { time: timePdu });
		}
		this.sendMessage("MSG_START"); // Start sending all relevant settings please
		this.sendMessage("MSG_EXIT");  // Exit download mode
	}

}

module.exports = PowerMax;
